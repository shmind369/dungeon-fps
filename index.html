<!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    
   
    <title>2025/07/09ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯FPS</title>
    <style>
      body {
        margin: 0;
        background: black;
        overflow: hidden;
        touch-action: none;
      }
      canvas {
        display: block;
      }
    </style>
   
  </head>
  <body>
  <canvas id="gameCanvas"></canvas>
  <script>
  // 2025/07/09 10:46 ã‚¢ãƒ­ãƒ¼é–¢æ•°ã®æ•´ç†
  // 2025/07/09  3:24 Gå¤‰æ•°ã€é–¢æ•°ã®æ•´ç† ã‚¾ãƒ³ãƒ“ã®ã‚µã‚¤ã‚ºoffsetã‚’80â†’40ã«å¤‰æ›´
  
  console.log();
  
  window.onload = function () {
    
    //initEnemies();

    player.nextAttackTime = 0; // æ¬¡ã«æ”»æ’ƒã§ãã‚‹æ™‚åˆ»
    
    //isCharging = false; 2025/07/10 1:56 å‰Šé™¤
    
    chargeStartTime = null;
  }
  
  //â†“æç”»é–¢ä¿‚
  
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
    
  const spriteSheet = new Image();
  spriteSheet.src = "sps.png";
  
  const numRays = Math.min(1024, canvas.width); // ç”»è³ªè½ã¡ã‚‹ã‘ã©è»½ããªã‚‹
  const maxDepth = 10;
  //const tileSize = 64;
  const TILE_SIZE = 32;
  const fov = Math.PI / 3;
  
  //â†‘æç”»é–¢ä¿‚


  //â†“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–¢é€£
  
  let player = {
    hp: 30,
    maxHp: 30,
    hunger: 100,
    maxHunger: 100,
    speed: 0.015,
    inventory: [],
    effects: []  // çŠ¶æ…‹ç•°å¸¸ãªã©
  };
  
  let hungerTick = 0;
  let equippedWeapon = null;//è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆ
  let selectedInventoryIndex = 0; //é¸æŠä¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
  const start = {x:1.5,y:1.5};
  let posX = start.x;
  let posY = start.y;
  let angle = 0;
  //const strafeAngle = angle + Math.PI / 2; // å³æ–¹å‘
  // ã¾ãŸã¯ angle - Math.PI / 2; ã§å·¦æ–¹å‘

  
  
  //const inventory = []; // 2025/07/07 23:44 ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãƒ¼ã‚’çµ±ä¸€ã™ã‚‹

  //â†‘ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–¢é€£
  
  //â†“ãƒãƒƒãƒ—é–¢é€£

  let map = generateRandomMap(16, 16);// ã“ã“ã§ãƒãƒƒãƒ—ã¨ã‚´ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
  let goal = findRandomEmptyTile(map);
  let explored = initializeExplored(map);
  const mapWidth = map[0].length;
  const mapHeight = map.length;
  let goalReached = false; //ã‚´ãƒ¼ãƒ«ã«åˆ°é”ã—ãŸã‹ã©ã†ã‹
  let goalInRange = false;
  let floor = 1;
  
  //â†‘ãƒãƒƒãƒ—é–¢é€£

  //â†“æ•µ/ã‚¢ã‚¤ãƒ†ãƒ /ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
  
  let enemies = [];
  let items = []; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®šç¾©
  const bullets = [];
  const thrownItems = [];
  const damageTexts = [];
  let particles = [];//ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
  let nearbyItemIndex = -1;

  //â†‘æ•µ/ã‚¢ã‚¤ãƒ†ãƒ /ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ

  //â†“ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œå‹•é–¢é€£
  
  let lastAttackTime = 0;
  const attackCooldown = 500; // ãƒŸãƒªç§’
  const attackRange = 1;     // è·é›¢ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
  const attackDamage = 1;     // ä¸ãˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸
  let isPunching = false;
  let punchTimer = 0;
  
  let charging = false;//ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ã‚¸
  let chargeThreshold = 100; // 100ãƒ•ãƒ¬ãƒ¼ãƒ ã§æº€ã‚¿ãƒ³
  let chargeInProgress = false;
  let isCharging = false;
  let chargeTime = 0;
  let chargeCallback = null;
  
  let showDropTargets = false;
  
  

  //â†‘ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œå‹•é–¢é€£

  //â†“ãã®ä»–
  
  let shakeTimer = 0;
  let shakeIntensity = 50;
  let warningTimer = 0;
  let gameCount = 0;
  let isGameOver = false;
  
  //â†‘ãã®ä»–
  
  const itemTemplates = {
    "ğŸãƒ‘ãƒ³": {
      type: "food",
      heal: 0,
      hunger: 30,
      throwDamage: 0,
      spriteRow: 0
    },
    
    "ğŸ’Šå›å¾©è–¬": {
      type: "medicine",
      heal: 20,
      throwDamage: 0,
      spriteRow: 1
    },
    
    "ğŸ’ŠåŠ é€Ÿã®è–¬": {
      type: "medicine",
      speed: 0.05,
      throwDamage: 0,
      spriteRow: 0
    },
    
    "ğŸ’Šéˆè¶³ã®è–¬": {
      type: "medicine",
      speed: -0.02,
      throwDamage: 0,
      spriteRow: 0
    },
    
    "ğŸ—¡ï¸çŸ­å‰£": {
      type: "weapon",
      damage: 5,
      throwDamage: 1,
      spriteRow: 2
    }
    
  };
  
  //carvePath(map,start,goal);

 
 /*2025/07/07 20:10 ãƒ†ã‚¹ãƒˆå‰Šé™¤ ä¸€å¿œå‰Šé™¤å¾Œã‚‚æ©Ÿèƒ½
  startCharge(() => {
      const item = items[nearbyItemIndex];
      inventory.push(item); // æ‰€æŒå“ã«è¿½åŠ 
      items.splice(nearbyItemIndex, 1); // ãƒãƒƒãƒ—ä¸Šã‹ã‚‰å‰Šé™¤
      nearbyItemIndex = -1;
      isDraggingItem = false;
    }, 60
  );
  */
  
  //â†“Enemyã‚¯ãƒ©ã‚¹---------------------
  class Enemy {
    constructor(x, y, spriteRow, hp = 3, speed = 0.001) {
      this.x = x;
      this.y = y;
      this.spriteRow = spriteRow; // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã®è¡Œç•ªå·
      this.hp = hp;
      this.alpha = 1.0;
      this.isDying = false;
      this.deathStartTime = 0;
      this.speed = speed;
      this.isAlive = true;
      this.attackCooldown = 0;
      this.hitTimer = 0;
    }
  
    update(playerX, playerY) {
      if (!this.isAlive) {
        this.updateFadeOut();
        return;
      }
  
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const distance = Math.hypot(dx, dy);
  
      if (distance < 0.5) {
        if (this.attackCooldown <= 0) {
          this.attackPlayer();
          this.attackCooldown = 60;
        }
      } else {
        if (distance === 0) return;
        const nx = this.x + (dx / distance) * this.speed;
        const ny = this.y + (dy / distance) * this.speed;
        const tileX = Math.floor(nx);
        const tileY = Math.floor(ny);
        if (map[tileY][tileX] === 0) {
          this.x = nx;
          this.y = ny;
        }
      }
  
      if (this.attackCooldown > 0) this.attackCooldown--;
    }
  
    attackPlayer() {
      player.hp -= 5;
      player.hp = Math.max(player.hp, 0);
      console.log("æ•µã®æ”»æ’ƒï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HP:", player.hp);
      shakeTimer = 20;
    }
  
  
    takeDamage(damage) {
      this.hp -= damage;
      this.hitTimer = 10;
    
      // ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ
      damageTexts.push(new DamageText(this.x, this.y, `${Math.abs(damage)}`));
      //damageTexts.push(new DamageText(this.x, this.y, `-${damage}`));
    
      let particleCount = 40;
      const offsetX = (Math.random() - 0.5) * 0.3;
      const offsetY = (Math.random() - 0.5) * 0.3;
    
      for (let j = 0; j < particleCount; j++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 0.5 + 0.1;
        const lifetime = 20 + Math.floor(Math.random() * 10);
        particles.push(
          new Particle(this.x + offsetX, this.y + offsetY, angle, speed, lifetime)
        );
      }
    
      if (this.hp <= 0 && !this.isDying) {
        this.isAlive = false;
        this.startDying();
      }
    }
  
    startDying() {
      this.isDying = true;
      this.deathStartTime = Date.now();
    }
  
    updateFadeOut() {
      const elapsed = Date.now() - this.deathStartTime;
      const fadeDuration = 1000;
      this.alpha = Math.max(0, 1 - elapsed / fadeDuration);
    }
  
    updateHitEffect() {
      if (this.hitTimer > 0) this.hitTimer--;
    }
  
    /*
    draw(ctx) {
      const spriteSize = 128;
      const sx = 0 * spriteSize;
      const sy = this.spriteRow * spriteSize;
  
      ctx.globalAlpha = this.alpha;
  
      ctx.drawImage(
        spriteSheet,
        sx, sy,
        spriteSize, spriteSize,
        this.x * TILE_SIZE,
        this.y * TILE_SIZE,
        TILE_SIZE, TILE_SIZE
      );
  
      ctx.globalAlpha = 1.0;
    }
    */
  }
  //â†‘Enemyã‚¯ãƒ©ã‚¹---------------------

  //ã‚¾ãƒ³ãƒ“ã‚¯ãƒ©ã‚¹â†“---------------------
  class ZombieEnemy extends Enemy {
    constructor(x, y) {
      super(x, y, 0, 3 , 0.002); // â†ã“ã“ã ã‘ä¿®æ­£
      this.type = "zombie";
    }
    
    update(playerX, playerY) {
      super.update(playerX, playerY);
  
      const dx = playerX - this.x;
      const dy = playerY - this.y;
      const dist = Math.hypot(dx, dy);
  
      if (dist === 0) return;
  
      const speed = this.speed;
      const nextX = this.x + (dx / dist) * speed;
      const nextY = this.y + (dy / dist) * speed;
  
      if (map[Math.floor(nextY)]?.[Math.floor(nextX)] === 0) {
        this.x = nextX;
        this.y = nextY;
      } else {
        const tryX = this.x + Math.sign(dx) * speed;
        const tryY = this.y + Math.sign(dy) * speed;
  
        if (map[Math.floor(this.y)]?.[Math.floor(tryX)] === 0) {
          this.x = tryX;
        } else if (map[Math.floor(tryY)]?.[Math.floor(this.x)] === 0) {
          this.y = tryY;
        }
      }
    }
  
    drawFromRaycastView(ctx) {
      if (!this.isAlive) return;
  
      ctx.save();
  
      const dx = this.x - posX;
      const dy = this.y - posY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angleToEnemy = Math.atan2(dy, dx) - angle;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToEnemy) > halfFov) {
        ctx.restore(); return;
      }
  
      const steps = Math.floor(distance * 10);
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const cx = posX + dx * t;
        const cy = posY + dy * t;
        if (map[Math.floor(cy)]?.[Math.floor(cx)] === 1) {
          ctx.restore(); return;
        }
      }
  
      const baseSize = 1000;
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(1500, baseSize / (distance + 0.2));
      const offsetY = 40;
  
      if (this.hitTimer > 0) {
        ctx.globalAlpha = 0.1;
      }
  
      const spriteSize = 128;
      const sx = (this.attackCooldown > 45) ? (1 * spriteSize) : (0 * spriteSize);
      const sy = 0 * spriteSize;
  
      ctx.drawImage(
        spriteSheet,
        sx, sy,
        spriteSize, spriteSize,
        screenX - size / 2,
        canvas.height / 2 - size / 2 + offsetY,
        size,
        size
      );
  
      ctx.globalAlpha = 1.0;
      ctx.restore();
    }
  }
  //ã‚¾ãƒ³ãƒ“ã‚¯ãƒ©ã‚¹â†‘--------------------------

  enemies.push(new ZombieEnemy(5.5, 1.5));

  //ãƒŸã‚¤ãƒ©ã‚¯ãƒ©ã‚¹â†“-----------------------
  class MummyEnemy extends Enemy {
    constructor(x, y) {
      super(x, y, 1,6, 0.0018); // HP8ã€ã‚¾ãƒ³ãƒ“ã‚ˆã‚Šå°‘ã—é…ã„
      this.type = "mummy";
    }
  
    update(playerX, playerY) {
      // ã‚¾ãƒ³ãƒ“ã¨åŒã˜æŒ™å‹•ã§OK
      super.update(playerX, playerY);
    }
  
    drawFromRaycastView(ctx) {
      if (!this.isAlive) return;
  
      const dx = this.x - posX;
      const dy = this.y - posY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angleToEnemy = Math.atan2(dy, dx) - angle;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToEnemy) > halfFov) return;
  
      // é®è”½ãƒã‚§ãƒƒã‚¯
      const steps = Math.floor(distance * 10);
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const cx = posX + dx * t;
        const cy = posY + dy * t;
        if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
      }
  
      const baseSize = 1000;
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(1500, baseSize / (distance + 0.2));
  
      const offsetY = 80;
      
      // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã‹ã‚‰åˆ‡ã‚Šå‡ºã—ã¦æç”»
      const spriteSize = 128;  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ1ãƒã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°
      const sx = (this.attackCooldown > 45) ? (1 * spriteSize) : (0 * spriteSize);
  
      //const sx = 0 * spriteSize; // å·¦ã‹ã‚‰ä½•ãƒã‚¹ç›®
      const sy = 1 * spriteSize; // ä¸Šã‹ã‚‰ä½•ãƒã‚¹ç›®
    
      ctx.drawImage(
        spriteSheet,          // â†ã“ã“ã‚’å˜ä½“ç”»åƒã˜ã‚ƒãªãã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã«ã™ã‚‹
        sx, sy,               // åˆ‡ã‚Šå‡ºã—å…ƒX,Y
        spriteSize, spriteSize, // åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
        screenX - size/2,
        canvas.height/2 - size/2 + offsetY,
        size,
        size
      );
      
    }
  }
  //ãƒŸã‚¤ãƒ©ã‚¯ãƒ©ã‚¹â†‘---------------------

  //ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ãƒ©ã‚¹â†“--------------------
  class DragonEnemy extends Enemy {
    constructor(x, y) {
      super(x, y, 2,20, 0.010); // HP8ã€ã‚¾ãƒ³ãƒ“ã‚ˆã‚Šå°‘ã—é…ã„
      this.type = "dragon";
    }
  
    update(playerX, playerY) {
      // ã‚¾ãƒ³ãƒ“ã¨åŒã˜æŒ™å‹•ã§OK
      super.update(playerX, playerY);
    }
  
    drawFromRaycastView(ctx) {
      if (!this.isAlive) return;
  
      const dx = this.x - posX;
      const dy = this.y - posY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angleToEnemy = Math.atan2(dy, dx) - angle;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToEnemy) > halfFov) return;
  
      // é®è”½ãƒã‚§ãƒƒã‚¯
      const steps = Math.floor(distance * 10);
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const cx = posX + dx * t;
        const cy = posY + dy * t;
        if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
      }
  
      const baseSize = 1000;
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(1500, baseSize / (distance + 0.2));
  
      const offsetY = 80;
  
       // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã‹ã‚‰åˆ‡ã‚Šå‡ºã—ã¦æç”»
      const spriteSize = 128;  // ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ1ãƒã‚¹ã®ãƒ”ã‚¯ã‚»ãƒ«æ•°
      const sx = (this.attackCooldown > 45) ? (1 * spriteSize) : (0 * spriteSize);
  
      //const sx = 0 * spriteSize; // å·¦ã‹ã‚‰ä½•ãƒã‚¹ç›®
      const sy = 2 * spriteSize; // ä¸Šã‹ã‚‰ä½•ãƒã‚¹ç›®
    
      ctx.drawImage(
        spriteSheet,          // â†ã“ã“ã‚’å˜ä½“ç”»åƒã˜ã‚ƒãªãã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚·ãƒ¼ãƒˆã«ã™ã‚‹
        sx, sy,               // åˆ‡ã‚Šå‡ºã—å…ƒX,Y
        spriteSize, spriteSize, // åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
        screenX - size/2,
        canvas.height/2 - size/2 + offsetY,
        size,
        size
      );
    }
  }
  //ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ãƒ©ã‚¹â†‘-----------------
    
  //ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹â†“-----------------
  class Item {
      constructor({x, y, name, type, weight, damage = 0, heal = 0, speed = 0, hunger = 0 }) {
        console.log("Item created",{x,y,name});
        this.x = x;
        this.y = y;
        this.name = name;
        this.type = type;
        this.weight = weight;
        this.damage = damage;
        this.heal = heal;
        this.speed = speed;
        this.picked = false;
        this.hunger = hunger;
      }
    
      use(player) {
        console.log(`use() called for ${this.name}`);

        console.log(`type=${this.type}, heal=${this.heal}, speed=${this.speed}, hunger=${this.hunger}`);
    
        let used = false;
    
        if (this.heal !== 0) {
          player.hp = Math.min(player.maxHp, player.hp + this.heal);
          console.log(`ğŸ’Š ${this.name} ã‚’ä½¿ã£ãŸï¼HP +${this.heal}`);
          used = true;
        }
    
        if (this.speed !== 0) {
          player.speed += this.speed;
          console.log(`ğŸ’Š ${this.name} ã‚’ä½¿ã£ãŸï¼Speed ${this.speed > 0 ? "+" : ""}${this.speed}`);
          used = true;
        }
        
        if (this.hunger !== 0) {
          player.hunger = Math.min(player.maxHunger, player.hunger + this.hunger);
          console.log(`ğŸ ${this.name} ã‚’é£Ÿã¹ãŸï¼æº€è…¹åº¦ +${this.hunger}`);
          used = true;
        }
    
        if (!used) {
          console.log(`âŒ åŠ¹æœãªã—`);
        }
    
        return used;
      }
    
    
      draw(ctx) {
        const dx = this.x - posX;
        const dy = this.y - posY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angleToItem = Math.atan2(dy, dx) - angle;
    
        const halfFov = fov / 2;
        const rayAngle = normalizeAngle(angle + angleToItem);
        const eyeX = Math.cos(rayAngle);
        const eyeY = Math.sin(rayAngle);
    
        let rayDist = 0;
        let hit = false;
        while (!hit && rayDist < maxDepth) {
          rayDist += 0.01;
          const testX = Math.floor(posX + eyeX * rayDist);
          const testY = Math.floor(posY + eyeY * rayDist);
          if (
            testX < 0 || testY < 0 ||
            testX >= mapWidth || testY >= mapHeight
          ) {
            hit = true;
            rayDist = maxDepth;
          } else if (map[testY][testX] > 0) {
            hit = true;
          }
        }
        
        if (Math.abs(angleToItem) < halfFov && distance < rayDist) {
          const screenX = (angleToItem + halfFov) / fov * canvas.width;
          const size = Math.max(5, 200 / distance);
          ctx.fillStyle = "green";
          ctx.font = `${size}px sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
        
          // ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ±ºå®š
          let icon = "ç‰©";  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
          if (this.type === "weapon") {
            icon = "ğŸ—¡ï¸";
          } else if (this.type === "medicine") {
            icon = "ğŸ’Š";
          } else if (this.type === "food"){
            icon = "ğŸ";
          }
        
          ctx.fillText(icon, screenX, canvas.height / 2);
        }
        
      }
    }
  //â†‘ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹------------------

  //â†“ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒ©ã‚¹------------------
  class DamageText {
    constructor(x, y, text) {
      this.x = x;
      this.y = y;
      this.text = text;
      this.age = 0; // è¡¨ç¤ºæ™‚é–“ã®ã‚«ã‚¦ãƒ³ãƒˆ
    }
  
    update() {
      this.y -= 0.01; // å°‘ã—ä¸Šã«æµ®ã‹ã›ã‚‹
      this.age++;
    }
  
    isAlive() {
      return this.age < 60; // 60ãƒ•ãƒ¬ãƒ¼ãƒ (1ç§’)è¡¨ç¤º
    }
  
    draw(ctx) {
      const dx = this.x - posX;
      const dy = this.y - posY;
      const distance = Math.hypot(dx, dy);
      const angleToEnemy = Math.atan2(dy, dx) - angle;
    
      const halfFov = fov / 2;
      if (Math.abs(angleToEnemy) > halfFov) return;
    
      // é®è”½åˆ¤å®šï¼ˆç°¡æ˜“ï¼‰
      const steps = Math.floor(distance * 10);
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const cx = posX + dx * t;
        const cy = posY + dy * t;
        if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
      }
    
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      //const offsetY = 0; // æµ®ãä¸ŠãŒã‚‹

      const offsetY = this.age * 1; // æµ®ãä¸ŠãŒã‚‹
    
      ctx.fillStyle = "red";
      ctx.font = "100px sans-serif";
      ctx.fillText(this.text, screenX, canvas.height / 2 + offsetY);
    }
  }
  //â†‘ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒ©ã‚¹-----------------

  //æŠ•ã’ã‚‹ã‚¯ãƒ©ã‚¹â†“----------------------
  class ThrownItem {
    constructor(x, y, vx, vy, item) {
      this.x = x;           // ç¾åœ¨ä½ç½® X
      this.y = y;           // ç¾åœ¨ä½ç½® Y
      this.vx = vx;         // Xæ–¹å‘ã®é€Ÿåº¦ï¼ˆåˆæœŸå€¤ï¼‰
      this.vy = vy;         // Yæ–¹å‘ã®é€Ÿåº¦ï¼ˆåˆæœŸå€¤ï¼‰
      this.item = item;     // æŠ•ã’ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
      this.age = 0;         // ãƒ•ãƒ¬ãƒ¼ãƒ çµŒéæ•°
      this.lifetime = 50;   // é£›ã¶é•·ã•
      this.isActive = true; // é£›è¡Œä¸­ã‹ã©ã†ã‹
    }
  
    update() {
    if (!this.isActive) return;
  
    // æ¬¡ã«ç§»å‹•ã™ã‚‹äºˆå®šã®åº§æ¨™
    const nextX = this.x + this.vx;
    const nextY = this.y + this.vy;
  
    // ç§»å‹•å…ˆãŒå£ã‹ã©ã†ã‹
    const tileX = Math.floor(nextX);
    const tileY = Math.floor(nextY);
  
    if (
      tileX < 0 || tileX >= mapWidth ||
      tileY < 0 || tileY >= mapHeight ||
      map[tileY][tileX] === 1 // å£
    ) {
      this.isActive = false;
  
      // å£ã«å½“ãŸã£ãŸä½ç½®ã«è½ä¸‹ã•ã›ã‚‹
    items.push(new Item({
        x: Math.floor(this.x),
        y: Math.floor(this.y),
        name: this.item.name,
        type: this.item.type,
        weight: this.item.weight,
        damage: this.item.damage || 0,
        heal: this.item.heal || 0,
        speed: this.item.speed || 0
    }));
      
      console.log(`æŠ•ã’ãŸã‚¢ã‚¤ãƒ†ãƒ ãŒå£ã«å½“ãŸã£ã¦è½ä¸‹ã—ã¾ã—ãŸ x=${this.x}, y=${this.y}`);
      return;
    }
  
    // å£ã«å½“ãŸã‚‰ãªã‘ã‚Œã°ç§»å‹•
    this.x = nextX;
    this.y = nextY;
  
    this.age++;
    
    // é£›ã³çµ‚ã‚ã£ãŸã‚‰è½ä¸‹
    if (this.age >= this.lifetime) {
      this.isActive = false;
        items.push(new Item({
          x: Math.floor(this.x),
          y: Math.floor(this.y),
          name: this.item.name,
          type: this.item.type,
          weight: this.item.weight,
          damage: this.item.damage || 0,
          heal: this.item.heal || 0,
          speed: this.item.speed || 0
        }));
      console.log(`æŠ•ã’ãŸã‚¢ã‚¤ãƒ†ãƒ ãŒå¯¿å‘½ã§è½ä¸‹ã—ã¾ã—ãŸ x=${this.x}, y=${this.y}`);
    }
  }
      draw(ctx) {
      if (!this.isActive) return;
    
      const dx = this.x - posX;
      const dy = this.y - posY;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const angleTo = Math.atan2(dy, dx) - angle;
      const halfFov = fov/2;
    
      if (Math.abs(angleTo) < halfFov) {
        const screenX = (angleTo + halfFov) / fov * canvas.width;
        const size = Math.max(2, 300 / (dist + 0.1));
        ctx.fillStyle = "orange";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height/2, size, 0, Math.PI*2);
        ctx.fill();
      }
    }
  }
  //æŠ•ã’ã‚‹ã‚¯ãƒ©ã‚¹â†‘------------------

  //â†“ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¯ãƒ©ã‚¹-------------------
  class Particle {
      constructor(x, y, angle, speed, lifetime) {
        this.x = x;
        this.y = y;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.lifetime = lifetime;
        this.age = 4;
      }
    
      update() {
        // é‡åŠ›
        this.vy += 0.015; // ã“ã‚ŒãŒã€Œè½ã¡ã‚‹ã€åŠ é€Ÿåº¦
    
        this.x += this.vx;
        this.y += this.vy;
    
        this.age++;
      }
    
      isAlive() {
        return this.age < this.lifetime;
      }
      
    draw(ctx) {
      const dx = this.x - posX;
      const dy = this.y - posY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angleToParticle = Math.atan2(dy, dx) - angle;
    
      const halfFov = fov / 2;
      if (Math.abs(angleToParticle) > halfFov) return;
    
      const steps = Math.floor(distance * 10);
      for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const cx = posX + dx * t;
        const cy = posY + dy * t;
        if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
      }
    
      const screenX = (angleToParticle + halfFov) / fov * canvas.width;
      const size = Math.max(5, 50 / (distance + 0.1));
    
      // è½ä¸‹è¡¨ç¾: ageã«å¿œã˜ã¦Yåº§æ¨™ã‚’ä¸‹ã’ã‚‹
      const offsetY = this.age * 30; // 2pxãšã¤ä¸‹ãŒã‚‹
    
      ctx.fillStyle = "yellow";
      ctx.beginPath();
      ctx.arc(screenX, canvas.height / 2 + offsetY, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  //â†‘ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¯ãƒ©ã‚¹--------------------

  //â†“ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
  function gameLoop() {
    
    warningTimer++;
    gameCount++;
  
    // ç”»é¢ã‚¯ãƒªã‚¢ã¯æœ€åˆã«1å›ã ã‘
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  
    // å„ç¨®å‡¦ç†
    getDirectionName();
    
    // æ•µã®æ›´æ–°ãƒ»æç”»
    updateEnemies();

    
    // è¡€ã—ã¶ãã‚’æ›´æ–°
    updeteParticles();
    
    updateDamageTexts();

    
    // ã‚¢ã‚¤ãƒ†ãƒ æŠ•ã’å½“ãŸã‚Šåˆ¤å®šãƒ«ãƒ¼ãƒ—
    handleThrownCollision();
    
    cleanUpThrownItems();


  
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ãƒ»å›è»¢
    if (!isDraggingItem) {
      if (isMovingForward) move(true);
      if (isMovingBackward) move(false);
      if (isTurningLeft) rotate(-0.05);
      if (isTurningRight) rotate(0.05);
    }
    
    updatePlayerMovement();//
  
    // ãã®ä»–ã®æ›´æ–°ãƒ»æç”»
    updateGoalProximity();
    checkNearbyItems();
    checkGoalCharging();
    updateNearbyItem();
    updateCharge();
    playerHunger();
    render();  // ã“ã“ã§ç”»é¢å…¨ä½“ã‚’å†æç”»ã™ã‚‹å ´åˆã€æ•µã®æç”»ã®å¾Œã«å‘¼ã°ãªã„ã‚ˆã†ã«èª¿æ•´ãŒå¿…è¦
    
    //startItemPickup();//2025/07/07 20:26
    
    markCurrentTileExplored();//ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨æ¢ç´¢æ¸ˆã¿

    //ctx.restore();
  
    if (player.hp <= 0) {
      isGameOver = true;
      return;
    }
  
    requestAnimationFrame(gameLoop);
  }
  //â†‘ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—

  //â†“ãƒ¬ãƒ³ãƒ€ãƒ¼ -------------------------
  function render() {
    
    ctx.save();
  
    applyScreenShake(ctx); // ç”»é¢ã‚’æºã‚‰ã™

    drawBackground(ctx);

    castRays();

    drawItems();
    drawEnemiesWithWarnings(ctx);
    drawDamageTexts(ctx);
    drawThrownItems(ctx);
    drawGoal();
    drawChargeGauge();
    drawStatusBars();
    drawPickupPrompt();
    drawInventory();
    drawMiniMap();
    drawPunchEffect();
    drawSelectedItem();
    drawDraggedItem();
    drawUseBox();
    drawFullDropZones();
    drawDirectionHUD();
    drawGameInfo();
    drawParticles(ctx);  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ä¸€ç•ªæœ€å¾Œã«æã

    renderGameOverScreenIfNeeded();
  
    ctx.restore();
  }
  //â†‘ãƒ¬ãƒ³ãƒ€ãƒ¼------------------

  function initNextFloor() {
      
    if (floor === 3) {
      // 3Fã ã‘è¿·è·¯ç”Ÿæˆ
      map = generateMazeMap(16, 16);
    } else {
      // ãã‚Œä»¥å¤–ã¯é€šå¸¸ãƒ©ãƒ³ãƒ€ãƒ ãƒãƒƒãƒ—
      map = generateRandomMap(16, 16);
    }
  
    map = generateRandomMap(16, 16);
    
    goal = findRandomEmptyTile(map);
  
    explored = Array.from({ length: map.length }, () =>
      Array.from({ length: map[0].length }, () => false)
    );
  
    posX = 1.5;
    posY = 1.5;
  
    carvePath(map, { x: posX, y: posY }, goal);
    
    initItems();
    initEnemies();
    
  }
  
  function generateRandomMap(width, height) {
    const newMap = [];
      for (let y = 0; y < height; y++) {
        const row = [];
        for (let x = 0; x < width; x++) {
          if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
            row.push(1); // å¤–å‘¨ã¯å£
          } else {
            row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
          }
        }
        newMap.push(row);
      }
      return newMap;
  }
  
  function generateMazeMap(width, height) {
    const maze = Array.from({ length: height }, () =>
      Array.from({ length: width }, () => 1)
  );
  
    function carve(x, y) {
      const directions = [
        [2, 0], [-2, 0], [0, 2], [0, -2]
      ].sort(() => Math.random() - 0.5);
  
      for (const [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (
          ny > 0 && ny < height &&
          nx > 0 && nx < width &&
          maze[ny][nx] === 1
        ) {
          maze[ny][nx] = 0;
          maze[y + dy / 2][x + dx / 2] = 0;
          carve(nx, ny);
        }
      }
    }
  
    // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹
    maze[1][1] = 0;
    carve(1, 1);
  
    return maze;
  }
  
  function carvePath(map, start, goal) {
    let x = Math.floor(start.x);
    let y = Math.floor(start.y);
    const gx = Math.floor(goal.x);
    const gy = Math.floor(goal.y);
  
    while (x !== gx || y !== gy) {
      map[y][x] = 0; // é“ã‚’æ˜ã‚‹
  
      if (Math.random() < 0.5 && x !== gx) {
        x += gx > x ? 1 : -1;
      } else if (y !== gy) {
        y += gy > y ? 1 : -1;
      }
    }
  }
  
  //â†“ç©ºãåœ°æ¡ˆå†…(ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨)-------------------
  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
      }
    }
  }
  //â†‘ç©ºãåœ°æ¡ˆå†…(ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨)-----------------
  
  //â†“ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨-----------------
  function initializeExplored(map) {
      return Array.from({ length: map.length }, () =>
        Array(map[0].length).fill(false)
      );
  }
  //â†‘ãƒŸãƒ‹ãƒãƒƒãƒ—ç”¨------------------

  function markCurrentTileExplored() {
    explored[Math.floor(posY)][Math.floor(posX)] = true;
  }
  
  //ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒé–¢é€£â†“
  function performAttack() {
    const now = Date.now();
    
    // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ãªã‚‰ä½•ã‚‚ã—ãªã„
    if (now < player.nextAttackTime) {
      console.log("æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ä¸­ï¼");
      return;
    }
    
    let damageToApply = 1; // ç´ æ‰‹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ€ãƒ¡ãƒ¼ã‚¸
    let cooldown = 1000;    // ç´ æ‰‹ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³(ms)
  
    if (equippedWeapon) {
      damageToApply = equippedWeapon.damage;
  
      // æ­¦å™¨åˆ¥ã«ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
      if (equippedWeapon.name.includes("çŸ­å‰£")) {
        cooldown = 1300; // çŸ­å‰£ã¯ç´ æ—©ã„
      } else if (equippedWeapon.name.includes("å¤§å‰£")) {
        cooldown = 2500; // å¤§å‰£ã¯é‡ã„
      }
    }
  
    // æ”»æ’ƒå‡¦ç†
    
    applyFrontAttackToEnemies(damageToApply);

  
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    if (equippedWeapon && equippedWeapon.name.includes("çŸ­å‰£")) {
      
      showZangekiEffect();

    } else if (!equippedWeapon) {
      isPunching = true;
      punchTimer = 0;
    }
  
    // æ¬¡ã«æ”»æ’ƒã§ãã‚‹æ™‚åˆ»ã‚’è¨­å®š
    player.nextAttackTime = now + cooldown;
  }
  //ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒé–¢é€£â†‘
  
  function applyFrontAttackToEnemies(damageToApply) {
    enemies.forEach(enemy => {
      if (!enemy.isAlive) return;
  
      const dx = enemy.x - posX;
      const dy = enemy.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToEnemy = Math.atan2(dy, dx);
      const diffAngle = Math.abs(normalizeAngle(angleToEnemy - angle));
  
      if (dist < attackRange && diffAngle < Math.PI / 4) {
        enemy.takeDamage(damageToApply);
        console.log(`æ•µã«${damageToApply}ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼`);
      }
    });
  }
  
  function playerHunger(){

      hungerTick++;
    if (hungerTick % 240 === 0) { // ç´„4ç§’ã«1å›
      player.hunger -= 1;
      if (player.hunger < 0) player.hunger = 0;
    }
  
    // è…¹åº¦ã‚¼ãƒ­ã§HPæ¸›å°‘ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (player.hunger === 0) {
      player.hp -= 0.05; // å°‘ã—ãšã¤HPã‚‚æ¸›ã‚‹
      if (player.hp < 0) player.hp = 0;
    }
  }


  //â†“ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼åˆæœŸåŒ–2025/07/05------------------
  function initEnemies() {
    enemies = [];
  
    if (floor >= 1 && floor <= 2) {
      spawnEnemies(5);
    }
  
    if (floor >= 3 && floor <= 5) {
      const mummyCount = 3 + Math.floor((floor - 3) * 1);
      for (let i = 0; i < mummyCount; i++) {
        const tile = findRandomEmptyTile(map);
        enemies.push(new MummyEnemy(tile.x, tile.y));
      }
      console.log(`éš${floor}: ãƒŸã‚¤ãƒ©ç”· ${mummyCount}ä½“ã‚’é…ç½®ï¼`);
    }
  
    if (floor === 5) {
      const dragonCount = 1;
      for (let i = 0; i < dragonCount; i++) {
        const tile = findRandomEmptyTile(map);
        enemies.push(new DragonEnemy(tile.x, tile.y));
      }
      console.log(`éš${floor}: ãƒ‰ãƒ©ã‚´ãƒ³ ${dragonCount}ä½“ã‚’é…ç½®ï¼`);
    }
  }
  //â†‘ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼åˆæœŸåŒ–2025/07/05------------------
  
  function spawnEnemy(x = null, y = null) {
    let spawnX = x;
    let spawnY = y;
  
    if (spawnX === null || spawnY === null) {
      do {
        spawnX = Math.floor(Math.random() * mapWidth);
        spawnY = Math.floor(Math.random() * mapHeight);
      } while (map[spawnY][spawnX] !== 0);
    }
  
    // ZombieEnemyã«ã™ã‚‹
    const newEnemy = new ZombieEnemy(spawnX + 0.5, spawnY + 0.5);
    enemies.push(newEnemy);
  
    console.log(`æ–°ã—ã„æ•µãŒå‡ºç¾: (${spawnX}, ${spawnY})`);
  }

  function spawnEnemies(count) {
      for (let i = 0; i < count; i++) {
        spawnEnemy();
      }
  }

  function updateEnemies(){
    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      enemy.update(posX, posY);
      enemy.updateHitEffect();
      if (enemy.isDying && enemy.alpha <= 0) {
        console.log("æ•µæ¶ˆæ»… å®Œäº†");
        enemies.splice(i, 1);
      }
    }
  }
  
  //â†“ã‚¢ã‚¤ãƒ†ãƒ åˆæœŸåŒ–2025/07/05----------------------------------
  function initItems() {
    const itemNames = [
      "ğŸ—¡ï¸çŸ­å‰£",
      "ğŸãƒ‘ãƒ³",
      "ğŸ’Šå›å¾©è–¬",
      "ğŸ’Šéˆè¶³ã®è–¬",
      "ğŸ’ŠåŠ é€Ÿã®è–¬"
    ];
  
    items.length = 0;
  
    for (let i = 0; i < 5; i++) {
      const tile = findRandomEmptyTile(map);
      const name = itemNames[Math.floor(Math.random() * itemNames.length)];
      const template = itemTemplates[name];
  
        if (!template) {
          console.error(`ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: ${name}`);
          continue;
        }
      
      items.push(new Item({
        x: tile.x,
        y: tile.y,
        name,
        type: template.type,
        weight: template.weight,
        damage: template.damage || 0,
        heal: template.heal || 0,
        speed: template.speed || 0,
        hunger: template.hunger || 0
      }));
      /*
      items.push(new Item(
        tile.x,
        tile.y,
        name,
        template.type,
        template.weight,
        template.damage || 0,
        template.heal || 0,
        template.hunger || 0,
        template.throwDamage || 0,
        template.speed || 0
      ));
      */
    }
  }
  //â†‘ã‚¢ã‚¤ãƒ†ãƒ åˆæœŸåŒ–--------------------------------------------
  
  function startItemPickup(durationFrames = 60) {
    startCharge(() => {
      const item = items[nearbyItemIndex];
      player.inventory.push(item);               // æ‰€æŒå“ã«è¿½åŠ 
      items.splice(nearbyItemIndex, 1);   // ãƒãƒƒãƒ—ä¸Šã‹ã‚‰å‰Šé™¤
      nearbyItemIndex = -1;               // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚»ãƒƒãƒˆ
      isDraggingItem = false;             // ãƒ‰ãƒ©ãƒƒã‚°è§£é™¤
    }, durationFrames);
  }

  function useSelectedItem() {
    const selectedItem = player.inventory[selectedInventoryIndex];
    if (!selectedItem) return;
  
    const used = selectedItem.use(player);
    if (used) {
      const index = player.inventory.indexOf(selectedItem);
      if (index !== -1) {
        console.log("ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤");
        player.inventory.splice(index, 1); // ä½¿ç”¨å¾Œå‰Šé™¤
      }
  
      // ã“ã“ã¯ä¸è¦: selectedItem = null;
      // ä»£ã‚ã‚Šã«é¸æŠã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
      selectedInventoryIndex = 0;
    }
  }
  
  function updeteParticles(){
    for (let i = particles.length - 1; i >= 0; i--) {
      particles[i].update();
      if (!particles[i].isAlive()) {
        particles.splice(i, 1);
      }
    }
  }
  
  function updateDamageTexts() {
    for (let i = damageTexts.length - 1; i >= 0; i--) {
      damageTexts[i].update();
      if (!damageTexts[i].isAlive()) {
        damageTexts.splice(i, 1);
      }
    }
  }
  
  function updateGoalProximity() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    goalInRange = dist < 0.5;
  }
  
  function updateNearbyItem() {
    nearbyItemIndex = -1; // åˆæœŸåŒ–
  
    items.forEach((item, index) => {
      const dx = item.x - posX;
      const dy = item.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.5) { // è¿‘ã‘ã‚Œã°
        nearbyItemIndex = index;
      }
    });
  }
  
  function updateCharge() {
    if (isCharging && chargeCallback) {
      chargeTime++;
      if (chargeTime >= chargeThreshold) {
        chargeCallback(); // æˆåŠŸæ™‚ã®å‡¦ç†ã‚’å®Ÿè¡Œ
        stopCharge();     // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
      }
    }else{
    }
  }
  
  /*
  function updatePlayerMovement() {
    if (isStrafingRight) moveRight();
    if (isStrafingLeft) moveLeft();
    if (isMovingForward) moveForward();
    if (isMovingBackward) moveBackward();
    
    if (isTurningQuick) {
      let targetAngle = 0;
      //let diff = quickTurnTargetAngle - angle;
      const diff = normalizeAngle(targetAngle - angle);
      //const diff = normalizeAngle(quickTurnTargetAngle - angle);
      //diff = Math.atan2(Math.sin(diff),Math.cos(diff));
      if (Math.abs(diff) < 0.1) {
        angle = quickTurnTargetAngle;
        isTurningQuick = false;
        console.log("ğŸ” ã‚¯ã‚¤ãƒƒã‚¯ã‚¿ãƒ¼ãƒ³å®Œäº†ï¼");
      } else {
        // å°‘ã—ãšã¤å›è»¢ã™ã‚‹ï¼ˆå³æ–¹å‘ã«æœ€çŸ­ã§ï¼‰
        angle += Math.sign(Math.sin(diff)) * quickTurnSpeed;
      }
    }
  }
  */
  
  function updatePlayerMovement() {
    if (isStrafingRight) moveRight();
    if (isStrafingLeft) moveLeft();
    if (isMovingForward) moveForward();
    if (isMovingBackward) moveBackward();
  
    if (isTurningQuick) {
      const diff = normalizeAngle(quickTurnTargetAngle - angle);
      
      if (Math.abs(diff) < 0.05) {
        angle = quickTurnTargetAngle;
        isTurningQuick = false;
        console.log("ğŸ” ã‚¯ã‚¤ãƒƒã‚¯ã‚¿ãƒ¼ãƒ³å®Œäº†ï¼");
      } else {
        angle += Math.sign(diff) * quickTurnSpeed;
      }
    }
  }


//â†“æç”»é–¢é€£------------------------------------

  function drawBackground(ctx) {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  } //2025/07/09 17:51 è¿½åŠ 

  function castRays() {
    
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (angle - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
      
      // è·é›¢ã«å¿œã˜ã¦å£ã®é«˜ã•ã‚’èª¿æ•´ï¼ˆé ã„ã»ã©å°ã•ãï¼‰
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    
    }
  }
  
  function drawGameInfo() {
    ctx.fillStyle = "white";
    ctx.font = "44px sans-serif";
    ctx.fillText(`${floor}F`, 200, 30);
  
    ctx.font = "20px sans-serif";
    ctx.fillText(`Count: ${gameCount}`, canvas.width - 150, 30);
  }
  
  function drawMiniMap() {
    const scale = 10;
    const mapWidthPx = map[0].length * scale;
    const mapHeightPx = map.length * scale;
  
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);
  
    for (let y = 0; y < map.length; y++) {
      for (let x = 0; x < map[0].length; x++) {
        if (!explored[y][x]) continue;
  
        ctx.fillStyle = (map[y][x] === 1) ? "gray" : "black";
        ctx.fillRect(x * scale, y * scale, scale, scale);
      }
    }
  
    // ğŸŸ¦ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ï¼ˆé’ï¼‰
    ctx.fillStyle = "blue";
    ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);
  }
  
  function drawStatusBars() {
    const barWidth = 200;
    const barHeight = 16;
    const margin = 20;
  
    // HPãƒãƒ¼
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = "orange";
    ctx.fillRect(margin, canvas.height - barHeight * 2 - margin, barWidth * hpRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight * 2 - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, margin + 5, canvas.height - barHeight * 2 - margin + 12);
  
    // æº€è…¹åº¦ãƒãƒ¼
    const hungerRatio = player.hunger / player.maxHunger;
    ctx.fillStyle = "green";
    ctx.fillRect(margin, canvas.height - barHeight - margin, barWidth * hungerRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`æº€è…¹åº¦: ${player.hunger}/${player.maxHunger}`, margin + 5, canvas.height - barHeight - margin + 12);
  }
  
  function drawInventory() {
    const padding = 20;
    const fontSize = 30;       // â† å¤§ããã—ãŸã„ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º
    const lineHeight = 40;     // â† è¡Œé–“ï¼ˆãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚º +10ãã‚‰ã„æ¨å¥¨ï¼‰
  
    const x = canvas.width - 200;
    let y = padding;
  
    ctx.font = `${fontSize}px sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
  
    // ã‚¿ã‚¤ãƒˆãƒ«
    ctx.fillStyle = "white";
    ctx.fillText("ğŸ’ ITEM", x, y);
    y += lineHeight;
  
    player.inventory.forEach((item, index) => {
      const itemText = item?.name || "(ä¸æ˜ãªã‚¢ã‚¤ãƒ†ãƒ )";
  
      // é¸æŠä¸­ã ã‘è‰²ã‚’å¤‰ãˆã‚‹
      ctx.fillStyle = index === selectedInventoryIndex ? "yellow" : "white";
  
      ctx.fillText(`- ${itemText}`, x, y + index * lineHeight);
    });
  }

  function drawSelectedItem() {
    if (player.inventory.length > 0) {
      const selectedItem = player.inventory[selectedInventoryIndex];
      if (selectedItem && selectedItem.name) {
        ctx.fillStyle = "white";
        ctx.font = "58px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`é¸æŠä¸­${selectedItem.name}`, canvas.width / 2, canvas.height - 100);
      }
      
    }
  }
  
  function drawDraggedItem() {
    if (isDraggingItem) {
      const item = player.inventory[selectedInventoryIndex];
      if (!item) return;
  
      ctx.fillStyle = "yellow";
      ctx.font = "28px sans-serif";
      ctx.fillText(item.name, dragX, dragY);
    }
  }
  
  function drawFullDropZones() {
    if (!isDraggingItem) return;
  
    const w = canvas.width / 2;
    const h = canvas.height / 2;
  
    const zones = [
      { x: 0, y: 0, label: "æŠ•ã’ã‚‹" },
      { x: w, y: 0, label: "ä½¿ã†" },
      { x: 0, y: h, label: "ç½®ã" },
      { x: w, y: h, label: ""},
    ];
  
    ctx.font = "28px sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
  
    zones.forEach(zone => {
      ctx.strokeStyle = "white";
      ctx.strokeRect(zone.x, zone.y, w, h);
      ctx.fillStyle = "white";
      if (zone.label) {
        ctx.fillText(zone.label, zone.x + w / 2, zone.y + h / 2);
      }
    });
  }
  
  function drawItems() {
    items.forEach(item => {
      item.draw(ctx); // â† å„ã‚¢ã‚¤ãƒ†ãƒ ã«æç”»å‡¦ç†ã‚’ä»»ã›ã‚‹
    });
   
  }
 
  function drawPunchEffect(){
    if (!isPunching) return;
  
    const spriteSize = 128;
  
    // é€²è¡Œåº¦ï¼ˆé€æ˜åº¦ã ã‘ã«ä½¿ã†ï¼‰
    const progress = punchTimer / 100;
    const alpha = 1 - progress;
  
    ctx.save();
    ctx.globalAlpha = alpha;
  
    // åˆ‡ã‚Šå‡ºã—ä½ç½®ï¼ˆè¡Œ7:ãƒ‘ãƒ³ãƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
    const sx = 0 * spriteSize; // åˆ—0
    const sy = 7 * spriteSize; // è¡Œ7
  
    ctx.drawImage(
      spriteSheet,
      sx, sy,
      spriteSize, spriteSize,
      0,                 // dx: å·¦ä¸Šã«é…ç½®
      0,                 // dy
      canvas.width,      // æç”»å¹…ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã«
      canvas.height      // æç”»é«˜ã•ã‚’ã‚­ãƒ£ãƒ³ãƒã‚¹å…¨ä½“ã«
    );
  
    ctx.restore();
  
    punchTimer++;
    if (punchTimer > 7) isPunching = false;
  }
  
  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - angle;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawChargeGauge() {
      if(!isCharging || chargeThreshold === 0)return;
  
    const width = 100;
    const height = 10;
    const x = canvas.width / 2 - width / 2;
    const y = canvas.height - 40;
  
    const ratio = Math.min(1, chargeTime / chargeThreshold);
  
    ctx.fillStyle = "gray";
    ctx.fillRect(x, y, width, height);
  
    ctx.fillStyle = "lime";
    ctx.fillRect(x, y, width * ratio, height);
  }
  
  function drawPickupPrompt() {
    if (nearbyItemIndex !== -1) {
      const item = items[nearbyItemIndex]; // ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’å–å¾—
  
      ctx.fillStyle = "white";
      ctx.font = "84px sans-serif";
      ctx.textAlign = "center";
     // ctx.fillText("ã€æ‹¾ã†ã€‘", canvas.width / 2, canvas.height - 80);
      ctx.fillText(`ã€${item.name}ã€‘`, canvas.width / 2, canvas.height - 580);
    }
  }
 
  function drawGameOverScreen() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    ctx.fillStyle = "red";
    ctx.font = "64px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
  
    ctx.fillStyle = "white";
    ctx.font = "24px sans-serif";
    ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 50);
  }
  
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const halfFov = fov / 2;

    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
  
      //ï¼šãã®æ–¹å‘ã®å£ã¨ã®è·é›¢ã‚’å–å¾—
      let rayAngle = normalizeAngle(angle+ angleToGoal);
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);
      let rayDist = 0;
      let hit = false;
      while (!hit && rayDist < maxDepth) {
        rayDist += 0.01;
        let testX = Math.floor(posX + eyeX * rayDist);
        let testY = Math.floor(posY + eyeY * rayDist);
        if (
          testX < 0 || testY < 0 ||
          testX >= mapWidth || testY >= mapHeight
        ) {
          hit = true;
          rayDist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
  
      // ã‚´ãƒ¼ãƒ«ãŒæ‰‹å‰ã«ã‚ã‚‹ã¨ãã ã‘æç”»
      if (dist < rayDist) {
        const maxSize = 180;
        const size = Math.max(4, maxSize / dist);
        
        ctx.fillStyle = "lime";
        ctx.font = `${size}px sans-serif`; // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼è¦‹ãŸç›®ã®å¤§ãã•
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("éš", screenX, canvas.height / 2);

      }
    }
  }
  
  function drawDirectionHUD() {
    const direction = getDirectionName(angle); // angleã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ä»®å®š
    ctx.font = "80px sans-serif";
    ctx.fillStyle = "White";
    ctx.fillText(`${direction}`, 10, 200);
  }
  
  function drawEnemyWarning(angleToEnemy) {
    const blink = Math.floor(warningTimer / 30) % 2 === 0;
    if (!blink) return;
  
    ctx.save();
    ctx.fillStyle = "red";
    ctx.font = "180px sans-serif";
    ctx.textAlign = "center";
  
    const normalized = normalizeAngle(angleToEnemy - angle);
    if (normalized < 0) {
      ctx.fillText("ï¼œï¼œï¸", 80, canvas.height / 2);
    } else {
      ctx.fillText("ï¼ï¼ï¸", canvas.width - 80, canvas.height / 2);
    }
  
    ctx.restore();
  }
  
  function drawEnemiesWithWarnings(ctx) {
    for (const enemy of enemies) {
      if (enemy.isAlive) {
          enemy.updateHitEffect();
          enemy.drawFromRaycastView(ctx);
    
          const dx = enemy.x - posX;
          const dy = enemy.y - posY;
          const distance = Math.hypot(dx, dy);
          const angleToEnemy = Math.atan2(dy, dx);
          const diff = Math.abs(normalizeAngle(angleToEnemy - angle));
    
          const isNearby = distance < 1.5;
          const isOutsideFov = diff > fov / 2;
    
        if (isNearby && isOutsideFov) {
          drawEnemyWarning(angleToEnemy);
        }
      }
    }
  }
  
  function drawFloorGridPerspective() {
      ctx.strokeStyle = "white";
      ctx.lineWidth = 1;
    
      // y: ã‚¹ã‚¯ãƒªãƒ¼ãƒ³Y
     for (let y = canvas.height / 2; y < canvas.height; ) {
      const depth = (y - canvas.height / 2) / (canvas.height / 2);
      const shade = Math.floor(255 - depth * 180); // å¥¥ã«ã„ãã»ã©æš—ã
      ctx.strokeStyle = `rgb(${shade},${shade},${shade})`;
    
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    
      y += Math.max(2, (y - canvas.height / 2) / 10);
    }
  }  //åºŠã®ã‚°ãƒªãƒƒãƒ‰æç”»2025/07/07

  function drawUseBox() {
    const size = 100; // æ­£æ–¹å½¢ã®ã‚µã‚¤ã‚º
    const x = canvas.width - size - 20; // å³ã‹ã‚‰20pxå†…å´
    const y = canvas.height / 1.75 - size / 2; // ç¸¦ä¸­å¤®ã«é…ç½®
  
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, size, size);
    
    // è£…å‚™ä¸­æ­¦å™¨ã®ã‚¢ã‚¤ã‚³ãƒ³
    if (equippedWeapon) {
      ctx.font = `${size * 0.5}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ—¡ï¸", x + size / 2, y + size / 2);
    }
  }
  
  function showZangekiEffect() {
    const effectDuration = 200; // ms
    const startTime = Date.now();
  
    function drawEffect() {
      const now = Date.now();
      if (now - startTime < effectDuration) {
        const spriteSize = 128;
  
        // åˆ‡ã‚Šå‡ºã—ä½ç½®
        const sx = 1 * spriteSize; // åˆ—0
        const sy = 7 * spriteSize; // è¡Œ0ï¼ˆæ–¬æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼‰
  
        ctx.drawImage(
          spriteSheet,
          sx, sy,
          spriteSize, spriteSize,
          0,                 // æç”»å…ˆXï¼ˆå·¦ç«¯ï¼‰
          0,                 // æç”»å…ˆYï¼ˆä¸Šç«¯ï¼‰
          canvas.width,      // æç”»å…ˆå¹…ï¼ˆå…¨ä½“ï¼‰
          canvas.height      // æç”»å…ˆé«˜ã•ï¼ˆå…¨ä½“ï¼‰
        );
  
        requestAnimationFrame(drawEffect);
      }
    }
  
    drawEffect();
  }
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  } //2025/07/09 19:36 è¿½åŠ 
  
  function applyScreenShake(ctx) {
    if (shakeTimer > 0) {
      const dx = (Math.random() - 0.5) * shakeIntensity;
      const dy = (Math.random() - 0.5) * shakeIntensity;
      ctx.translate(dx, dy);
      shakeTimer--;
    }
  } //2025/07/09 17:37 ç”»é¢ã‚’æºã‚‰ã™
  
  function drawDamageTexts(ctx) {
    for (const dt of damageTexts) {
      dt.draw(ctx);
    }
  } //2025/07/09 17:46 è¿½åŠ 

  function drawThrownItems(ctx) {
    for (const thrown of thrownItems) {
      thrown.draw(ctx);
    }
  } //2025/07/09 17:46 è¿½åŠ 
  
  function drawParticles(ctx) {
    for (const p of particles) {
      p.draw(ctx);
    }
  } //2025/07/09 17:48 è¿½åŠ 
  
  function renderGameOverScreenIfNeeded() {
    if (isGameOver) {
      drawGameOverScreen();
    }
  } //2025/07/09 17:54 è¿½åŠ 
  
//â†‘æç”»é–¢é€£----------------------------
  
  function handleDrop(item, target) {
    if (target === "usebox") {
      if (item.type === "weapon") {
        equippedWeapon = item;
        console.log(`è£…å‚™ã—ã¾ã—ãŸ: ${item.name}`);
      } else {
        useItem(item);
      }
  
      // ãƒ‰ãƒ­ãƒƒãƒ—å¾Œã¯ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
      const index = player.inventory.indexOf(item);
      if (index !== -1) player.inventory.splice(index, 1);
    }
  }  // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†

  function throwSelectedItem() {
    const item = player.inventory[selectedInventoryIndex];
    if (!item) return;
  
    const speed = 0.4;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
  
    thrownItems.push(new ThrownItem(posX, posY, vx, vy, item));
    player.inventory.splice(selectedInventoryIndex, 1);
  
    console.log(`ğŸ’¥ æŠ•ã’ãŸï¼`);
  }
  
  function cleanUpThrownItems(){
    for (let i = thrownItems.length - 1; i >= 0; i--) {
        thrownItems[i].update();
          if (!thrownItems[i].isActive) {
            thrownItems.splice(i, 1);
        }
    }
  }
  
  function handleThrownCollision(){
    for (const thrown of thrownItems) {
      if (!thrown.isActive) continue;
      for (const enemy of enemies) {
        const dx = enemy.x - thrown.x;
        const dy = enemy.y - thrown.y;
        if (Math.hypot(dx, dy) < 0.5) {
          // ãƒ€ãƒ¡ãƒ¼ã‚¸åŠ¹æœ
          if (thrown.item.damage > 0) {
            enemy.takeDamage(thrown.item.damage);
            console.log(`ğŸ—¡ï¸ ${thrown.item.name}ãŒå‘½ä¸­ï¼${thrown.item.damage}ãƒ€ãƒ¡ãƒ¼ã‚¸`);
          }
    
          // ã‚¹ãƒ”ãƒ¼ãƒ‰åŠ¹æœ
          if (thrown.item.speed < 0) {
            const newSpeed = enemy.speed * 0.5;
  // 0ä»¥ä¸‹ã¯0.01ã«ã™ã‚‹
            enemy.speed = newSpeed <= 0 ? 0.01 : newSpeed;
            console.log(`éˆè¶³ã®è–¬ãŒå‘½ä¸­ï¼æ•µã®ã‚¹ãƒ”ãƒ¼ãƒ‰: ${enemy.speed}`);
            
          }
          
          if (thrown.item.speed > 0) {
            const newSpeed = enemy.speed * 1.5;
  
            enemy.speed = newSpeed <= 0 ? 0.01 : newSpeed;
            console.log(`åŠ é€Ÿã®è–¬ãŒå‘½ä¸­ï¼æ•µã®ã‚¹ãƒ”ãƒ¼ãƒ‰: ${enemy.speed}`);
            
          }
    
          // ä»–ã«åŠ¹æœã‚’è¶³ã—ãŸã‘ã‚Œã°ã“ã“ã«
    
          // æŠ•æ“²ã‚¢ã‚¤ãƒ†ãƒ ã¯æ¶ˆãˆã‚‹
          thrown.isActive = false;
        }
      }
    }
  }
  
  function checkNearbyItems() {
    nearbyItemIndex = -1;
    for (let i = 0; i < items.length; i++) {
      const dx = items[i].x - posX;
      const dy = items[i].y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.6) {
        nearbyItemIndex = i; // è¿‘ãã®ã‚¢ã‚¤ãƒ†ãƒ ç•ªå·
        break;
      }
    }
  }

  function checkGoalCharging() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const isInGoalArea = dist < 0.5;
  
    if (isInGoalArea && charging && !isCharging) {
      startCharge(() => {
        floor++;
        console.log("æ¬¡ã®éšå±¤ã¸ï¼");
        initNextFloor(); // å¿…è¦ãªã‚‰ã“ã“ã§éšå±¤é·ç§»å‡¦ç†
      }, 100); // 100ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„1.6ç§’ï¼‰ãªã©
    }
  }
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  }

  function isInUseBox(touchX, touchY) {
    const size = 100;
    const x = canvas.width - size - 20;
    const y = canvas.height / 1.75 - size / 2;
    return (
      touchX >= x &&
      touchX <= x + size &&
      touchY >= y &&
      touchY <= y + size
    );
  }
  
  function getDirectionName(angle) {
    const angleDeg = (angle * 180 / Math.PI + 360) % 360;
  
    //if (angleDeg >= 22.5 && angleDeg < 67.5) return "å—æ±â†˜";
    if (angleDeg >= 67.5 && angleDeg < 112.5) return "Sâ†“";
    //if (angleDeg >= 112.5 && angleDeg < 157.5) return "å—è¥¿â†™";
    if (angleDeg >= 157.5 && angleDeg < 202.5) return "Wâ†";
    //if (angleDeg >= 202.5 && angleDeg < 247.5) return "åŒ—è¥¿â†–";
    if (angleDeg >= 247.5 && angleDeg < 292.5) return "Nâ†‘";
    //if (angleDeg >= 292.5 && angleDeg < 337.5) return "åŒ—æ±â†—";
    return "Eâ†’";
  }

  function startCharge(callback, threshold = 60) {
    
    if(isCharging){
      console.log("ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒ£ãƒ¼ã‚¸å®Ÿè¡Œ",{threshold});
      return;
    }
      isCharging = true;
      chargeTime = 0;
      chargeCallback = callback;
      chargeThreshold = threshold;
  }
  
  function stopCharge() {
    isCharging = false;
    chargeTime = 0;
    chargeCallback = null;
    isDraggingItem = false;
  }
  
  function rotate(deltaAngle) {
    angle += deltaAngle;
    angle =  normalizeAngle(angle);
  }

  function move(forward) {
    const moveSpeed = forward ? player.speed : -player.speed / 2;
    const nextX = posX + Math.cos(angle) * moveSpeed;
    const nextY = posY + Math.sin(angle) * moveSpeed;
  
    // å£ãƒã‚§ãƒƒã‚¯
    if (map[Math.floor(nextY)][Math.floor(nextX)] !== 0) return;
  
    // æ•µã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆçœç•¥ã›ãšå…ƒã®ã¾ã¾ã§OKï¼‰
    let blocked = false;
    for (const enemy of enemies) {
      if (!enemy.isAlive) continue;
      const dx = enemy.x - nextX;
      const dy = enemy.y - nextY;
      const dist = Math.hypot(dx, dy);
      const angleToEnemy = Math.atan2(dy, dx);
      const diffAngle = Math.abs(normalizeAngle(angleToEnemy - angle));
      const frontAngleThreshold = Math.PI / 2;
  
      if (dist < 0.4 && diffAngle < frontAngleThreshold) {
        blocked = true;
        break;
      }
    }
  
    if (blocked) {
      if (!forward) {
        const escapeX = posX + Math.cos(angle) * moveSpeed;
        const escapeY = posY + Math.sin(angle) * moveSpeed;
        if (map[Math.floor(escapeY)][Math.floor(escapeX)] === 0) {
          posX = escapeX;
          posY = escapeY;
        }
      }
      return;
    }
  
    posX = nextX;
    posY = nextY;
  }

  function moveForward() {
    move(true);
  }

  function moveBackward() {
    move(false);
  }
  /*
  function moveLeft() {
    const sideSpeed = 0.04; // ç§»å‹•é€Ÿåº¦
    const dx = Math.sin(angle);  // â†è§’åº¦ã«ç›´äº¤ã™ã‚‹ãƒ™ã‚¯ãƒˆãƒ«
    const dy = -Math.cos(angle);
    const nextX = posX - dx * sideSpeed;
    const nextY = posY - dy * sideSpeed;
    
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function moveRight() {
    const sideSpeed = 0.04;
    const dx = Math.sin(angle);
    const dy = -Math.cos(angle);
    const nextX = posX + dx * sideSpeed;
    const nextY = posY + dy * sideSpeed;
    
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }
  */
  
  function moveRight() {
    const strafeAngle = angle + Math.PI / 2; // è¦–ç·šã®å³å´ã¸90åº¦
    const strafeSpeed = player.speed;
    const nextX = posX + Math.cos(strafeAngle) * strafeSpeed;
    const nextY = posY + Math.sin(strafeAngle) * strafeSpeed;
  
    // å£ãŒãªã„ã‹ç¢ºèªã—ã¦ã‹ã‚‰ç§»å‹•
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function moveLeft() {
    const strafeAngle = angle - Math.PI / 2; // è¦–ç·šã®å·¦å´ã¸90åº¦
    const strafeSpeed = player.speed;
    const nextX = posX + Math.cos(strafeAngle) * strafeSpeed;
    const nextY = posY + Math.sin(strafeAngle) * strafeSpeed;
  
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }
  
  function quickTurn() {
    if (isTurningQuick) return; // ã™ã§ã«å›è»¢ä¸­ãªã‚‰ç„¡è¦–
  
    quickTurnTargetAngle = normalizeAngle(angle + Math.PI);
    isTurningQuick = true;
    console.log("ğŸ” ã‚¯ã‚¤ãƒƒã‚¯ã‚¿ãƒ¼ãƒ³é–‹å§‹ï¼");
  }
  
//â†“ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆé–¢é€£
  //â†“ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆé–¢é€£å¤‰æ•°
  
    const TAP_THRESHOLD = 10;
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // â†å·¦å›è»¢ãƒ•ãƒ©ã‚°
    let isTurningRight = false;  // â†å³å›è»¢ãƒ•ãƒ©ã‚°
    let touchStartY = null;
    let touchStartX = null;
    
    
    //â†“ã‚¯ã‚¤ãƒƒã‚¯ã‚¿ãƒ¼ãƒ³ç”¨ 2025/07/10 10:09
    let lastSwipeTime = 0;
    let lastSwipeDirection = null;
    const DOUBLE_SWIPE_THRESHOLD = 400; // ãƒŸãƒªç§’ä»¥å†…ãªã‚‰ãƒ€ãƒ–ãƒ«ã¨ã¿ãªã™
    
    let isTurningQuick = false;
    let quickTurnTargetAngle = 0;
    let quickTurnSpeed = 0.1; // â† èª¿æ•´å¯èƒ½ï¼ˆæ•°å€¤ãŒå°ã•ã„ã¨ã‚†ã£ãã‚Šï¼‰
    //â†‘ã‚¯ã‚¤ãƒƒã‚¯ã‚¿ãƒ¼ãƒ³ç”¨ 2025/07/10 10:09

    
    //let draggingItem = false;
    let dragX = 0;
    let dragY = 0;
    
    let inventoryTouchStartY = null;
    let isInventorySwipeAllowed = false;
    
    let isDraggingItem = false;
    let wasDraggingItem = false;
    let isDragging = false;
 
    let isSwipeAllowed = false;
    
    let isStrafingLeft = false; //ã‚«ãƒ‹æ­©ãç”¨
    let isStrafingRight = false; //ã‚«ãƒ‹æ­©ãç”¨
    
    //â†‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆé–¢é€£å¤‰æ•°

  //â†“ã‚¿ãƒƒãƒã‚¹ã‚¿ãƒ¼ãƒˆ
  canvas.addEventListener("touchstart", (e) => {
   
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    const yInCanvas = touch.clientY - rect.top;
    
    touchStartY = touch.clientY;
    touchStartX = touch.clientX;
    inventoryTouchStartY = touch.clientY;
    isInventorySwipeAllowed = yInCanvas < canvas.height - 200;
  
    const item = player.inventory[selectedInventoryIndex];
    const textX = canvas.width / 2 - 40;
    const textY = canvas.height - 60;
    const dist = Math.hypot(touch.clientX - textX, touch.clientY - textY);
    
    // ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹åˆ¤å®š
    if (item && dist < 100) {
      isDraggingItem = true;
      wasDraggingItem = true;
      dragX = touch.clientX;
      dragY = touch.clientY;
      console.log("ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹",dragX,dragY,  "isDraggingItem:", isDraggingItem);
      render(); // å³æç”»
      return;
    }
    
    if (isInUseBox(touch.clientX, touch.clientY) && equippedWeapon) {
        // è£…å‚™è§£é™¤
        console.log(`è£…å‚™è§£é™¤: ${equippedWeapon.name}`);
        player.inventory.push(equippedWeapon); // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã™
        isDraggingItem = true;
        wasDraggingItem = true;
        selectedInventoryIndex = player.inventory.length - 1; // æ–°ãŸã«è¿½åŠ ã—ãŸæ­¦å™¨
        equippedWeapon = null;
    }
    
    
    // æ”»æ’ƒå‡¦ç†ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã˜ã‚ƒãªã„ã€ã‹ã¤ãƒãƒ£ãƒ¼ã‚¸ã—ã¦ãªã„ã¨ãï¼‰
    if (!isDraggingItem && !charging) {
      const now = Date.now();
      if (now - lastAttackTime > attackCooldown) {
        lastAttackTime = now;
      }
    }
  
    // ã‚¢ã‚¤ãƒ†ãƒ å–å¾— or ã‚´ãƒ¼ãƒ«ãƒãƒ£ãƒ¼ã‚¸
    if (nearbyItemIndex !== -1) {
      
      startCharge(() => {
        player.inventory.push(items[nearbyItemIndex]);
        items.splice(nearbyItemIndex, 1);
        nearbyItemIndex = -1;
      }, 60);
    } else if (goalInRange) {
      startCharge(() => {
        floor++;
        initNextFloor();
      }, 100);
    }
  
  
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    if (isGameOver) location.reload();
  
    }, { passive: true });
  //â†‘ã‚¿ãƒƒãƒã‚¹ã‚¿ãƒ¼ãƒˆ

  /*â†“ã‚¿ãƒƒãƒãƒ ãƒ¼ãƒ–
  
  canvas.addEventListener("touchmove", (e) => {
    if (isDraggingItem) {
      const touch = e.touches[0];
      dragX = touch.clientX;
      dragY = touch.clientY;
      
      return; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ä»–å‡¦ç†ç„¡è¦–
    }
  
    if (touchStartY === null || touchStartX === null) return;
  
    const touchY = e.touches[0].clientY;
    const touchX = e.touches[0].clientX;
  
    const dy = touchStartY - touchY;
    const dx = touchX - touchStartX;
  
    if (isDragging && Math.abs(dragDeltaX) > Math.abs(dragDeltaY)) {
      if (dragDeltaX > 20) {
        moveRight(); // ã‚«ãƒ‹æ­©ãå³
      } else if (dragDeltaX < -20) {
        moveLeft(); // ã‚«ãƒ‹æ­©ãå·¦
      }
    }
  
    // å‰é€²ãƒ»å¾Œé€€
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    } else if (dy < -50) {
      isMovingForward = false;
      isMovingBackward = true;
    }
  
    // å›è»¢
    if (dx > 50) {
      isTurningRight = true;
      isTurningLeft = false;
      rotate(0.2);
      touchStartX = touchX;
    } else if (dx < -50) {
      isTurningLeft = true;
      isTurningRight = false;
      rotate(-0.2);
      touchStartX = touchX;
    }
  }, { passive: false });
  */
  canvas.addEventListener("touchmove", (e) => {
    if (isDraggingItem) {
      const touch = e.touches[0];
      dragX = touch.clientX;
      dragY = touch.clientY;
      return; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ä»–å‡¦ç†ç„¡è¦–
    }
  
    if (touchStartY === null || touchStartX === null) return;
  
    const touchY = e.touches[0].clientY;
    const touchX = e.touches[0].clientX;
  
    const dx = touchX - touchStartX;
    const dy = touchStartY - touchY;
  
    // âœ… ã‚«ãƒ‹æ­©ãï¼ˆå·¦å³ï¼‰
    if (Math.abs(dx) > Math.abs(dy)) {
      if (dx > 20) {
        isStrafingRight = true;
        isStrafingLeft = false;
      } else if (dx < -20) {
        isStrafingLeft = true;
        isStrafingRight = false;
      }
    }
    
    // âœ… å‰é€²ãƒ»å¾Œé€€
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    } else if (dy < -50) {
      isMovingForward = false;
      isMovingBackward = true;
    }
  
    // âœ… è¦–ç‚¹å›è»¢ï¼ˆä»»æ„ï¼‰
    if (dx > 50) {
      rotate(0.2);
      touchStartX = touchX;
    } else if (dx < -50) {
      rotate(-0.2);
      touchStartX = touchX;
    }
  }, { passive: false });
  

  //â†“ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰
  canvas.addEventListener("touchend", (e) => {
    const touchEndX = e.changedTouches[0].clientX;
    const touchEndY = e.changedTouches[0].clientY;
    const dx = touchEndX - touchStartX;
    const dy = touchEndY - touchStartY;
    const distance = Math.hypot(dx, dy);
    const now = Date.now();
  
    // ã‚¹ãƒ¯ã‚¤ãƒ—æ–¹å‘åˆ¤å®š
    let currentSwipeDirection = null;
    if (dy > 50) currentSwipeDirection = "down";
    else if (dy < -50) currentSwipeDirection = "up";
  
    if (currentSwipeDirection) {
      if (
        currentSwipeDirection === lastSwipeDirection &&
        now - lastSwipeTime < DOUBLE_SWIPE_THRESHOLD &&
        currentSwipeDirection === "down"
      ) {
        console.log("â¬‡â¬‡ ãƒ€ãƒ–ãƒ«ã‚¹ãƒ¯ã‚¤ãƒ—æ¤œå‡ºï¼ï¼ˆ", currentSwipeDirection, "ï¼‰");
        quickTurn();
      }
      lastSwipeDirection = currentSwipeDirection;
      lastSwipeTime = now;
    }
  
    // ã‚¹ãƒˆãƒ¬ã‚¤ãƒ•ç­‰ã®ãƒªã‚»ãƒƒãƒˆ
    isStrafingLeft = false;
    isStrafingRight = false;
    isMovingForward = false;
    isMovingBackward = false;
  
    // --- ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°
    const angleDeg = angle * 180 / Math.PI;
    console.log(`ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä»Š ${angleDeg.toFixed(1)}Â° ã®æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹`);
    console.log("ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®: X =", posX.toFixed(2), "Y =", posY.toFixed(2));
  
    // --- ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
    if (wasDraggingItem) {
      console.log("ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã«ã¯ã„ã‚Šã¾ã—ãŸ");
      const x = touchEndX;
      const y = touchEndY;
      const w = canvas.width / 2;
      const h = canvas.height / 2;
  
      let action = null;
      if (x < w && y < h) action = "throw";
      else if (x >= w && y < h) action = "use";
      else if (x < w && y >= h) action = "drop";
  
      console.log("æœ€çµ‚ä½ç½®:", x, y, "action:", action);
  
      const item = player.inventory[selectedInventoryIndex];
      if (item) {
        if (isInUseBox(touchEndX, touchEndY)) {
          handleDrop(item, "usebox");
        } else {
          switch (action) {
            case "throw":
              console.log("æŠ•ã’ãŸï¼");
              throwSelectedItem();
              break;
            case "drop":
              console.log("åœ°é¢ã«ç½®ã„ãŸï¼");
                items.push(new Item({
                  x: posX,
                  y: posY,
                  name: item.name,
                  type: item.type,
                  weight: item.weight,
                  damage: item.damage || 0,
                  heal: item.heal || 0,
                  speed: item.speed || 0
                }));
              
              break;
            case "use":
              console.log("ä½¿ç”¨ã—ãŸï¼");
              useSelectedItem();
              break;
            default:
              console.log("ä½•ã‚‚ã—ãªã„ã‚¨ãƒªã‚¢ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸ");
              break;
          }
        }
      }
  
      // ãƒ‰ãƒ©ãƒƒã‚°å¾Œã®åˆæœŸåŒ–
      isDraggingItem = false;
      wasDraggingItem = false;
      showDropTargets = false;
      tapHandled = true;
  
      return; // ä»–ã®å‡¦ç†ã«é€²ã¾ãªã„
    }

    // ã‚¿ãƒƒãƒ—ã§æ”»æ’ƒ
    if (distance < TAP_THRESHOLD) {
      performAttack();
    }
  
    // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒ¯ã‚¤ãƒ—
    if (inventoryTouchStartY !== null && isInventorySwipeAllowed) {
      const endY = e.changedTouches[0].clientY;
      const diffY = endY - inventoryTouchStartY;
  
      if (Math.abs(diffY) > 50) {
        selectedInventoryIndex += diffY > 0 ? 1 : -1;
        const len = player.inventory.length;
        selectedInventoryIndex = len > 0 ? (selectedInventoryIndex + len) % len : 0;
      }
    }
  
    // å…±é€šãƒªã‚»ãƒƒãƒˆ
    inventoryTouchStartY = null;
    isInventorySwipeAllowed = false;
    isTurningLeft = false;
    isTurningRight = false;
    touchStartX = null;
    touchStartY = null;
    stopCharge();
  });
  //â†‘ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰
//â†‘ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆé–¢é€£
  
  gameLoop();
  </script>
  
  </body>
  </html>
