<!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    <!--<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">-->
   
    <title>2025/06/23ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯FPS</title>
    <style>
      body {
        margin: 0;
        background: black;
        overflow: hidden;
        touch-action: none;
      }
      canvas {
        display: block;
      }
    </style>
   
  </head>
  <body>
 
  <canvas id="gameCanvas"></canvas>
  <script>
  
  //
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const TILE_SIZE = 32;
  const fov = Math.PI / 3;
  
 

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
 /*
 canvas.addEventListener("touchmove", (e) => {
  e.preventDefault(); // ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢
  // ã“ã“ã«ç§»å‹•ã‚„å›è»¢å‡¦ç†ã‚’æ›¸ã
}, { passive: false }); // ğŸ‘ˆ ã“ã‚ŒãŒè¶…é‡è¦ï¼*/

  const zombieImage = new Image();
    zombieImage.src = "Zombie.png";
    
  const mummyImage = new Image();
    mummyImage.src = "Mummy.png";
    
  const dragonImage = new Image();
    dragonImage.src = "Dragon.png";
    
  const punchImage = new Image();
    punchImage.src = "Punch.png";
    
    
  // çŸ­å‰£æ”»æ’ƒç”¨ã®æ–¬æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”»åƒã‚’ãƒ­ãƒ¼ãƒ‰
  const zangekiImg = new Image();
    zangekiImg.src = "Zangeki.png";
  
  
  let player = {
    hp: 30,
    maxHp: 30,
    hunger: 100,
    maxHunger: 100,
    inventory: [],
    effects: []  // çŠ¶æ…‹ç•°å¸¸ãªã©
  };
  
  let shakeTimer = 0;
  let shakeIntensity = 50;
  
  let   lastAttackTime = 0;
  const attackCooldown = 500; // ãƒŸãƒªç§’
  const attackRange = 1;     // è·é›¢ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
  const attackDamage = 1;     // ä¸ãˆã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸
  
  let isPunching = false;
  let punchTimer = 0;
  
  let enemies = []; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®šç¾©
  
  let gameCount = 0;
  
  let isGameOver = false;
  
  let selectedInventoryIndex = 0; //é¸æŠä¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹(ä»®)
  
  let particles = [];
  

  
  // ã“ã“ã§ãƒãƒƒãƒ—ã¨ã‚´ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
  let map = generateRandomMap(16, 16);
  let goal = findRandomEmptyTile(map);
    
  let explored = [];
  
      for (let y = 0; y < map.length; y++) {
        explored[y] = [];
      for (let x = 0; x < map[0].length; x++) {
        explored[y][x] = false; // ã¾ã æ¢ç´¢ã—ã¦ã„ãªã„
      }
    }
    
    const start = {x:1.5,y:1.5};
    
    carvePath(map,start,goal);
    let posX = start.x;
    let posY = start.y;
  
  //ãƒ•ãƒ­ã‚¢ã®èª¿æ•´
  let floor = 1;
  
  
  const bullets = [];
  
  

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
 
  let angle = 0;
  
  let warningTimer = 0;
  
  
  
  //ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ã‚¸
  let charging = false;
  //let chargeTime = 0;
  let chargeThreshold = 100; // 100ãƒ•ãƒ¬ãƒ¼ãƒ ã§æº€ã‚¿ãƒ³
  //ã“ã“ã¾ã§
  
  let chargeInProgress = false;


  //let posX = 3.5, posY = 3.5; angle = 0;// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
  //let dir = 0; // è¦–ç‚¹ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  

  const inventory = [];
  
  
  let items = []; // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã§å®šç¾©

  window.onload = function () {
    
  
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã“ã“ã§åˆæœŸåŒ–
    const itemNames = [
      "ğŸ—¡ï¸çŸ­å‰£",
      //"ğŸ—¡ï¸é’éŠ…å‰£",
      "ğŸãƒ‘ãƒ³",
      //"ğŸ•¯ï¸æ¾æ˜",
      //"ğŸ¹æœ¨ã®çŸ¢",
      //"ğŸ”‘éµ",
      "ğŸ’Šå›å¾©è–¬",
      "ğŸ’Šéˆè¶³ã®è–¬",
      "ğŸ’Šä¿Šè¶³ã®è–¬"
      ];
    items = Array.from({ length: 10 }, () => {
      const name = itemNames[Math.floor(Math.random() * itemNames.length)];
      let type = "misc";
      let damage = 0;
      let heal = 0;
  
      if (name.includes("å›å¾©è–¬")) {
        type = "medicine";
        heal = 20;
      }
      else if (name.includes("ãƒ‘ãƒ³")) type = "food";
      else if (name.includes("éˆè¶³")) type = "medicine";
      else if (name.includes("ä¿Šè¶³")) type = "medicine";
      else if (name.includes("çŸ­å‰£")) {
        type = "weapon";
        damage = 5;
      }
  
      return new Item(
        Math.floor(Math.random() * 14) + 1.5,
        Math.floor(Math.random() * 14) + 1.5,
        name,
        type,
        name.includes("çŸ­å‰£")? 1.0:2.5,
        damage,
        heal
      );
      
        
    });
    
    
    
    isCharging = false;
    chargeStartTime = null;
  }
  

 
  
    

  
  
  
 
  //const numRays = canvas.width;
  // ä¾‹: ãƒ¬ã‚¤æœ¬æ•°ã‚’åˆ¶é™
  const numRays = Math.min(1024, canvas.width); // ç”»è³ªè½ã¡ã‚‹ã‘ã©è»½ããªã‚‹
  
  const maxDepth = 10;
  

  // âœ… â‘  Enemy ã‚¯ãƒ©ã‚¹ã‚’å…ˆã«å®šç¾©
  class Enemy {
  /**
   * æ•µã‚¯ãƒ©ã‚¹
   * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½è·¡ãƒ»æ”»æ’ƒã—ã€å€’ã•ã‚Œã‚‹ã¨å¾ã€…ã«é€æ˜ã«ãªã£ã¦æ¶ˆãˆã‚‹ã€‚
   */
  constructor(x, y, hp = 3, speed = 0.02) {
    this.x = x;               // æ•µã®Xåº§æ¨™ï¼ˆã‚¿ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹åº§æ¨™ï¼‰
    this.y = y;               // æ•µã®Yåº§æ¨™
    this.hp = hp;             // æ•µã®HP
    this.alpha = 1.0;         // æ•µã®é€æ˜åº¦ï¼ˆ1.0=å®Œå…¨è¡¨ç¤ºã€0=æ¶ˆæ»…ï¼‰
    this.isDying = false;     // æ¶ˆæ»…ä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
    this.deathStartTime = 0;  // æ¶ˆæ»…é–‹å§‹æ™‚åˆ»
    this.speed = speed;       // ç§»å‹•é€Ÿåº¦
    this.isAlive = true;      // ç”Ÿå­˜ãƒ•ãƒ©ã‚°ï¼ˆæ”»æ’ƒãƒ»ç§»å‹•ã®åˆ¤å®šã«ä½¿ç”¨ï¼‰
    this.attackCooldown = 0;  // æ”»æ’ƒã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ å˜ä½ï¼‰
    this.hitTimer = 0;        // è¢«å¼¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã‚¿ã‚¤ãƒãƒ¼
  }

  /**
   * æ•µã®çŠ¶æ…‹æ›´æ–°ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ å‘¼ã°ã‚Œã‚‹ï¼‰
   */
  update(playerX, playerY) {
    if (!this.isAlive) {
      // æ¶ˆæ»…ä¸­ã¯é€æ˜åº¦æ›´æ–°ã®ã¿è¡Œã†
      this.updateFadeOut();
      return;
    }

    const dx = playerX - this.x;
    const dy = playerY - this.y;
    const distance = Math.hypot(dx, dy);

    // æ”»æ’ƒå‡¦ç†
    if (distance < 0.5) {
      if (this.attackCooldown <= 0) {
        this.attackPlayer();
        this.attackCooldown = 60; // 1ç§’ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
      }
    } else {
      
      if(distance === 0) return;
      // ç§»å‹•å‡¦ç†
      const nx = this.x + (dx / distance) * this.speed;
      const ny = this.y + (dy / distance) * this.speed;
      const tileX = Math.floor(nx);
      const tileY = Math.floor(ny);
      if (map[tileY][tileX] === 0) {
        this.x = nx;
        this.y = ny;
      }
    }

    if (this.attackCooldown > 0) this.attackCooldown--;
  }

  /**
   * ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã‚‹
   */
  attackPlayer() {
    player.hp -= 5;
    player.hp = Math.max(player.hp, 0);
    console.log("æ•µã®æ”»æ’ƒï¼ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®HP:", player.hp);
    shakeTimer = 20; // ç”»é¢æºã‚ŒåŠ¹æœ
  }

  /**
   * ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã¨ãã®å‡¦ç†
   */
  takeDamage(damage) {
    this.hp -= damage;
    this.hitTimer = 10;
    
    if (this.hp <= 0 && !this.isDying) {
      this.isAlive = false;
      this.startDying();
    }

  
  }

  /**
   * æ¶ˆæ»…ã‚¨ãƒ•ã‚§ã‚¯ãƒˆé–‹å§‹
   */
  startDying() {
    this.isDying = true;
    this.deathStartTime = Date.now();
  }

  /**
   * æ¶ˆæ»…æ™‚ã®é€æ˜åº¦æ›´æ–°
   * å¾ã€…ã« alpha ã‚’ä¸‹ã’ã‚‹
   */
  updateFadeOut() {
    const elapsed = Date.now() - this.deathStartTime;
    const fadeDuration = 1000; // 1ç§’ã§å®Œå…¨æ¶ˆæ»…
    this.alpha = Math.max(0, 1 - elapsed / fadeDuration);
  }

  /**
   * è¢«å¼¾ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°
   */
  updateHitEffect() {
    if (this.hitTimer > 0) this.hitTimer--;
  }

  /**
   * æ•µã®æç”»
   */
  draw(ctx) {
    ctx.globalAlpha = this.alpha;

    // è¢«å¼¾ä¸­ã¯èµ¤ãè¡¨ç¤ºã€ãã‚Œä»¥å¤–ã¯ç·‘
    if (this.hitTimer > 0) {
      ctx.fillStyle = "red";
    } else {
      ctx.fillStyle = "green";
    }

    ctx.fillRect(this.x * tileSize, this.y * tileSize, tileSize, tileSize);
    ctx.globalAlpha = 1.0; // æç”»å¾Œã¯ alpha ã‚’ãƒªã‚»ãƒƒãƒˆ
  }
}

//ã‚¾ãƒ³ãƒ“ã‚¯ãƒ©ã‚¹â†“
  class ZombieEnemy extends Enemy {
  constructor(x, y) {
    super(x, y, 5, 0.002);
    this.type = "zombie";
  }

  update(playerX, playerY) {
    super.update(playerX, playerY);
    
    const dx = playerX - this.x;
    const dy = playerY - this.y;
    const dist = Math.hypot(dx, dy);
    const speed = this.speed;
  
    const nextX = this.x + dx / dist * speed;
    const nextY = this.y + dy / dist * speed;
  
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      this.x = nextX;
      this.y = nextY;
    } else {
      // å£ã«ã¶ã¤ã‹ã£ãŸã¨ãï¼šæ–œã‚ç§»å‹• or æ¨ªç§»å‹•ã§å›é¿ã‚’è©¦ã¿ã‚‹
      const tryX = this.x + Math.sign(dx) * speed;
      const tryY = this.y + Math.sign(dy) * speed;
  
      if (map[Math.floor(this.y)][Math.floor(tryX)] === 0) {
        this.x = tryX;
      } else if (map[Math.floor(tryY)][Math.floor(this.x)] === 0) {
        this.y = tryY;
      }
    }

  }

  
  drawFromRaycastView(ctx) {
    if (!this.isAlive) return;

    ctx.save();

    const dx = this.x - posX;
    const dy = this.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToEnemy = Math.atan2(dy, dx) - angle;
    const halfFov = fov / 2;
   

    if (Math.abs(angleToEnemy) > halfFov) {
      ctx.restore(); return;
    }

    // é®è”½ãƒã‚§ãƒƒã‚¯
    const steps = Math.floor(distance * 10);
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const cx = posX + dx * t;
      const cy = posY + dy * t;
      if (map[Math.floor(cy)][Math.floor(cx)] === 1) {
        ctx.restore(); return;
      }
    }

    const baseSize = 1000;

    const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
    const size = Math.min(1500, baseSize / (distance+0.2));
    
    const offsetY = 80;

    
    if(this.hitTimer > 0){
      ctx.globalAlpha = 0.1;
       
    }

    ctx.drawImage(zombieImage, screenX - size / 2, canvas.height / 2 - size / 2+offsetY, size, size);
    ctx.globalAlpha = 1.0;
    ctx.restore();
  }
}
//ã‚¾ãƒ³ãƒ“ã‚¯ãƒ©ã‚¹â†‘

//ãƒŸã‚¤ãƒ©ã‚¯ãƒ©ã‚¹â†“
  class MummyEnemy extends Enemy {
  constructor(x, y) {
    super(x, y, 20, 0.0018); // HP8ã€ã‚¾ãƒ³ãƒ“ã‚ˆã‚Šå°‘ã—é…ã„
    this.type = "mummy";
  }

  update(playerX, playerY) {
    // ã‚¾ãƒ³ãƒ“ã¨åŒã˜æŒ™å‹•ã§OK
    super.update(playerX, playerY);
  }

  drawFromRaycastView(ctx) {
    if (!this.isAlive) return;

    const dx = this.x - posX;
    const dy = this.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToEnemy = Math.atan2(dy, dx) - angle;
    const halfFov = fov / 2;

    if (Math.abs(angleToEnemy) > halfFov) return;

    // é®è”½ãƒã‚§ãƒƒã‚¯
    const steps = Math.floor(distance * 10);
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const cx = posX + dx * t;
      const cy = posY + dy * t;
      if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
    }

    const baseSize = 1000;
    const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
    const size = Math.min(1500, baseSize / (distance + 0.2));

    const offsetY = 80;

    ctx.save();
    ctx.drawImage(mummyImage, screenX - size / 2, canvas.height / 2 - size / 2 + offsetY, size, size);
    ctx.restore();
  }
}
//ãƒŸã‚¤ãƒ©ã‚¯ãƒ©ã‚¹â†‘

//ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ãƒ©ã‚¹â†“
  class DragonEnemy extends Enemy {
  constructor(x, y) {
    super(x, y, 20, 0.010); // HP8ã€ã‚¾ãƒ³ãƒ“ã‚ˆã‚Šå°‘ã—é…ã„
    this.type = "dragon";
  }

  update(playerX, playerY) {
    // ã‚¾ãƒ³ãƒ“ã¨åŒã˜æŒ™å‹•ã§OK
    super.update(playerX, playerY);
  }

  drawFromRaycastView(ctx) {
    if (!this.isAlive) return;

    const dx = this.x - posX;
    const dy = this.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToEnemy = Math.atan2(dy, dx) - angle;
    const halfFov = fov / 2;

    if (Math.abs(angleToEnemy) > halfFov) return;

    // é®è”½ãƒã‚§ãƒƒã‚¯
    const steps = Math.floor(distance * 10);
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const cx = posX + dx * t;
      const cy = posY + dy * t;
      if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
    }

    const baseSize = 1000;
    const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
    const size = Math.min(1500, baseSize / (distance + 0.2));

    const offsetY = 80;

    ctx.save();
    ctx.drawImage(dragonImage, screenX - size / 2, canvas.height / 2 - size / 2 + offsetY, size, size);
    ctx.restore();
  }
}
//ãƒ‰ãƒ©ã‚´ãƒ³ã‚¯ãƒ©ã‚¹â†‘


  enemies.push(new ZombieEnemy(5.5, 1.5));
  
  
  /*function spawnEnemy(x = null, y = null) {
    // ãƒ©ãƒ³ãƒ€ãƒ åº§æ¨™ã‚’æ±ºå®šï¼ˆæŒ‡å®šãŒç„¡ã‘ã‚Œã°ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ï¼‰
    let spawnX = x;
    let spawnY = y;
  
    if (spawnX === null || spawnY === null) {
      do {
        spawnX = Math.floor(Math.random() * mapWidth);
        spawnY = Math.floor(Math.random() * mapHeight);
      } while (map[spawnY][spawnX] !== 0);  // é€šè·¯ï¼ˆ0ï¼‰ã®å ´æ‰€ã«å‡ºç¾
    }
  
    // æ•µã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ä½œæˆã—ã¦è¿½åŠ 
    const newEnemy = new Enemy(spawnX + 0.5, spawnY + 0.5); // ä¸­å¤®å¯„ã›
    enemies.push(newEnemy);
  
    console.log(`ğŸ§Ÿ æ–°ã—ã„æ•µãŒå‡ºç¾: (${spawnX}, ${spawnY})`);
  }
  
  function spawnEnemies(count) {
    for (let i = 0; i < count; i++) {
      spawnEnemy(5);
    }
  }
  */
  function spawnEnemy(x = null, y = null) {
  let spawnX = x;
  let spawnY = y;

  if (spawnX === null || spawnY === null) {
    do {
      spawnX = Math.floor(Math.random() * mapWidth);
      spawnY = Math.floor(Math.random() * mapHeight);
    } while (map[spawnY][spawnX] !== 0);
  }

  // â­ï¸ã“ã“ã‚’ZombieEnemyã«ã™ã‚‹
  const newEnemy = new ZombieEnemy(spawnX + 0.5, spawnY + 0.5);
  enemies.push(newEnemy);

  console.log(`ğŸ§Ÿ æ–°ã—ã„æ•µãŒå‡ºç¾: (${spawnX}, ${spawnY})`);
}

function spawnEnemies(count) {
    for (let i = 0; i < count; i++) {
      spawnEnemy(3);
    }
  }

//ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹â†“
class Item {
  constructor(x, y, name, type, weight,damage = 0,heal = 0 ) {
    this.x = x;
    this.y = y;
    this.name = name;
    this.type = type;
    this.picked = false;
    this.weight = weight;
    this.damage = damage;
    this.heal = heal;
  }

  use(player) {
    console.log(`use() called for ${this.name}`);
    console.log(`type=${this.type}, heal=${this.heal}`);
    if (this.heal > 0) {
      player.hp = Math.min(player.maxHp, player.hp + this.heal);
      console.log(`ğŸ’Š ${this.name} ã‚’ä½¿ã£ãŸï¼HP +${this.heal}`);
      return true;
    }
    console.log(`âŒ åŠ¹æœãªã—`);
    return false;
  }

  draw(ctx) {
    const dx = this.x - posX;
    const dy = this.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - angle;

    const halfFov = fov / 2;
    const rayAngle = normalizeAngle(angle + angleToItem);
    const eyeX = Math.cos(rayAngle);
    const eyeY = Math.sin(rayAngle);

    let rayDist = 0;
    let hit = false;
    while (!hit && rayDist < maxDepth) {
      rayDist += 0.01;
      const testX = Math.floor(posX + eyeX * rayDist);
      const testY = Math.floor(posY + eyeY * rayDist);
      if (
        testX < 0 || testY < 0 ||
        testX >= mapWidth || testY >= mapHeight
      ) {
        hit = true;
        rayDist = maxDepth;
      } else if (map[testY][testX] > 0) {
        hit = true;
      }
    }
    
    if (Math.abs(angleToItem) < halfFov && distance < rayDist) {
      const screenX = (angleToItem + halfFov) / fov * canvas.width;
      const size = Math.max(5, 200 / distance);
      ctx.fillStyle = "gold";
      ctx.font = `${size}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
    
      // ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ±ºå®š
      let icon = "ç‰©";  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      if (this.type === "weapon") {
        icon = "ğŸ—¡ï¸";
      } else if (this.type === "medicine") {
        icon = "ğŸ’Š";
      } else if (this.type === "food"){
        icon = "ğŸ";
      }
    
      ctx.fillText(icon, screenX, canvas.height / 2);
    }
    /*
    if (Math.abs(angleToItem) < halfFov && distance < rayDist) {
      const screenX = (angleToItem + halfFov) / fov * canvas.width;
      const size = Math.max(5, 200 / distance);
      ctx.fillStyle = "gold";
      ctx.font = `${size}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ç‰©", screenX, canvas.height / 2);
    }
    */
  }
}
//ã‚¢ã‚¤ãƒ†ãƒ ã‚¯ãƒ©ã‚¹â†‘

items.push(new Item(2,2,"å›å¾©è–¬","heal"));

 function useSelectedItem() {
  const selectedItem = player.inventory[selectedInventoryIndex];
  if (!selectedItem) return;

  const used = selectedItem.use(player);
  if (used) {
    const index = player.inventory.indexOf(selectedItem);
    if (index !== -1) {
      console.log("ã‚¢ã‚¤ãƒ†ãƒ å‰Šé™¤");
      player.inventory.splice(index, 1); // ä½¿ç”¨å¾Œå‰Šé™¤
    }

    // ã“ã“ã¯ä¸è¦: selectedItem = null;
    // ä»£ã‚ã‚Šã«é¸æŠã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒªã‚»ãƒƒãƒˆ
    selectedInventoryIndex = 0;
  }
}

  class Particle {
    constructor(x, y, angle, speed, lifetime) {
      this.x = x;
      this.y = y;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed;
      this.lifetime = lifetime;
      this.age = 1;
    }
  
    update() {
      // ğŸˆ é‡åŠ›
      this.vy += 0.005; // ã“ã‚ŒãŒã€Œè½ã¡ã‚‹ã€åŠ é€Ÿåº¦
  
      this.x += this.vx;
      this.y += this.vy;
  
      this.age++;
    }
  
    isAlive() {
      return this.age < this.lifetime;
    }
    
  draw(ctx) {
    const dx = this.x - posX;
    const dy = this.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToParticle = Math.atan2(dy, dx) - angle;
  
    const halfFov = fov / 2;
    if (Math.abs(angleToParticle) > halfFov) return;
  
    const steps = Math.floor(distance * 10);
    for (let i = 1; i < steps; i++) {
      const t = i / steps;
      const cx = posX + dx * t;
      const cy = posY + dy * t;
      if (map[Math.floor(cy)][Math.floor(cx)] === 1) return;
    }
  
    const screenX = (angleToParticle + halfFov) / fov * canvas.width;
    const size = Math.max(1, 10 / (distance + 0.1));
  
    // ğŸŒŸ è½ä¸‹è¡¨ç¾: ageã«å¿œã˜ã¦Yåº§æ¨™ã‚’ä¸‹ã’ã‚‹
    const offsetY = this.age * 70; // 2pxãšã¤ä¸‹ãŒã‚‹
  
    ctx.fillStyle = "green";
    ctx.beginPath();
    ctx.arc(screenX, canvas.height / 2 + offsetY, size, 0, Math.PI * 2);
    ctx.fill();
  }
}
  
    function generateRandomMap(width, height) {
  const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // å¤–å‘¨ã¯å£
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
        }
      }
      newMap.push(row);
    }
    return newMap;
  }


  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
      }
    }
  }
  

  
  
  function carvePath(map, start, goal) {
    let x = Math.floor(start.x);
    let y = Math.floor(start.y);
    const gx = Math.floor(goal.x);
    const gy = Math.floor(goal.y);
  
    while (x !== gx || y !== gy) {
      map[y][x] = 0; // é“ã‚’æ˜ã‚‹
  
      if (Math.random() < 0.5 && x !== gx) {
        x += gx > x ? 1 : -1;
      } else if (y !== gy) {
        y += gy > y ? 1 : -1;
      }
    }
  }
  
  function drawMiniMap() {
  const scale = 10;
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue;

      ctx.fillStyle = (map[y][x] === 1) ? "gray" : "black";
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // ğŸŸ¦ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ï¼ˆé’ï¼‰
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);

  /*
  
  //æ•µã®ä½ç½®
  ctx.fillStyle = "red";
    enemies.forEach(enemy => {
      if (!enemy.isAlive) return;
      ctx.fillRect(Math.floor(enemy.x * scale), Math.floor(enemy.y * scale), scale, scale);
    });*/
}


/*function drawMiniEnemy(enemy) {
  const scale = 10;
  ctx.fillStyle = "red";
  ctx.fillRect(Math.floor(enemy.x * scale), Math.floor(enemy.y * scale), scale, scale);
}*/

    
  // è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆ
  let equippedWeapon = null;
  
  // ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
  function handleDrop(item, target) {
    if (target === "usebox") {
      if (item.type === "weapon") {
        equippedWeapon = item;
        console.log(`è£…å‚™ã—ã¾ã—ãŸ: ${item.name}`);
      } else {
        useItem(item);
      }
  
      // ãƒ‰ãƒ­ãƒƒãƒ—å¾Œã¯ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‹ã‚‰å‰Šé™¤
      const index = player.inventory.indexOf(item);
      if (index !== -1) player.inventory.splice(index, 1);
    }
  }
  
  function drawStatusBars() {
    const barWidth = 200;
    const barHeight = 16;
    const margin = 20;
  
    // HPãƒãƒ¼
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = "orange";
    ctx.fillRect(margin, canvas.height - barHeight * 2 - margin, barWidth * hpRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight * 2 - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, margin + 5, canvas.height - barHeight * 2 - margin + 12);
  
    // æº€è…¹åº¦ãƒãƒ¼
    const hungerRatio = player.hunger / player.maxHunger;
    ctx.fillStyle = "green";
    ctx.fillRect(margin, canvas.height - barHeight - margin, barWidth * hungerRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`æº€è…¹åº¦: ${player.hunger}/${player.maxHunger}`, margin + 5, canvas.height - barHeight - margin + 12);
  }

  function drawInventory() {
    
  const padding = 20;            // å³ç«¯ãƒ»ä¸Šç«¯ã‹ã‚‰ã®ä½™ç™½
  const lineHeight = 24;         // è¡Œé–“
  const fontSize = 40;

  const x = canvas.width - 200;  // â† å¸¸ã«å³ç«¯ï¼ˆç”»é¢å¹…ã‹ã‚‰200pxåˆ†å·¦ã¸ï¼‰
  let y = padding + fontSize;    // ä¸Šç«¯ã‹ã‚‰ä½™ç™½ã‚’å–ã£ã¦é–‹å§‹ä½ç½®

  ctx.fillStyle = "white";
  ctx.font = `${fontSize}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.fillText("ğŸ’ ITEM", x, y);
  y += lineHeight;

  player.inventory.forEach((item, index) => {
    const itemText = item?.name || "(ä¸æ˜ãªã‚¢ã‚¤ãƒ†ãƒ )";
    ctx.fillText(`- ${itemText}`, x, y + index * lineHeight);
      if (item && item.name) {
      ctx.fillStyle = index === selectedInventoryIndex ? "yellow" : "white";
      ctx.fillText(`- ${item.name}`, x, y + index * 20);
    }
  });
}

  function drawSelectedItem() {
    if (player.inventory.length > 0) {
      const selectedItem = player.inventory[selectedInventoryIndex];
      if (selectedItem && selectedItem.name) {
        ctx.fillStyle = "white";
        ctx.font = "58px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`é¸æŠä¸­${selectedItem.name}`, canvas.width / 2, canvas.height - 100);
      }
      
    }
  }
  
  
 function drawDraggedItem() {
  if (isDraggingItem) {
    const item = player.inventory[selectedInventoryIndex];
    if (!item) return;

    ctx.fillStyle = "yellow";
    ctx.font = "28px sans-serif";
    ctx.fillText(item.name, dragX, dragY);
  }
}
  
  function drawFullDropZones() {
  if (!isDraggingItem) return;

  const w = canvas.width / 2;
  const h = canvas.height / 2;

  const zones = [
    { x: 0, y: 0, label: "æŠ•ã’ã‚‹(é–‹ç™ºä¸­)" },
    { x: w, y: 0, label: "ä½¿ã†" },              // â† ã“ã“ãŒä½™ç™½
    { x: 0, y: h, label: "ç½®ã" },
    { x: w, y: h, label: ""},
  ];

  ctx.font = "28px sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  zones.forEach(zone => {
    ctx.strokeStyle = "white";
    ctx.strokeRect(zone.x, zone.y, w, h);
    ctx.fillStyle = "white";
    if (zone.label) {
      ctx.fillText(zone.label, zone.x + w / 2, zone.y + h / 2);
    }
  });
}


  


 
  
  let hungerTick = 0;
  
  function playerHunger(){

      hungerTick++;
    if (hungerTick % 240 === 0) { // ç´„4ç§’ã«1å›
      player.hunger -= 1;
      if (player.hunger < 0) player.hunger = 0;
    }
  
    // è…¹åº¦ã‚¼ãƒ­ã§HPæ¸›å°‘ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (player.hunger === 0) {
      player.hp -= 0.05; // å°‘ã—ãšã¤HPã‚‚æ¸›ã‚‹
      if (player.hp < 0) player.hp = 0;
    }
  }



  function drawItems() {
    items.forEach(item => {
      item.draw(ctx); // â† å„ã‚¢ã‚¤ãƒ†ãƒ ã«æç”»å‡¦ç†ã‚’ä»»ã›ã‚‹
    });
   
  }
  
  
  
  
 function drawPunchEffect() {
  if (!isPunching || !punchImage.complete) return;

  const progress = punchTimer / 100;
  const alpha = 1 - progress;
  const scale = 0.7 + 0.3 * progress;

  const imgWidth = punchImage.width * scale;
  const imgHeight = punchImage.height * scale;

  const offsetX = 65;
  const offsetY = 100;

  const x = canvas.width / 2 - imgWidth / 2 + offsetX;
  const y = canvas.height / 2 - imgHeight / 2 + offsetY;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.drawImage(punchImage, x, y, imgWidth+offsetX, imgHeight+offsetY);
  ctx.restore();

  punchTimer++;
  if (punchTimer > 7) isPunching = false;
}
  
  
//ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒé–¢é€£â†“
  function performAttack() {
    let damageToApply = 1; // ç´ æ‰‹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ”»æ’ƒåŠ›
  
    if (equippedWeapon) {
      damageToApply = equippedWeapon.damage;
    }
  
    enemies.forEach((enemy, i) => {
      if (!enemy.isAlive) return;
  
      const dx = enemy.x - posX;
      const dy = enemy.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToEnemy = Math.atan2(dy, dx);
      const diffAngle = Math.abs(normalizeAngle(angleToEnemy - angle));
  
      if (dist < attackRange && diffAngle < Math.PI / 4) {
        enemy.takeDamage(damageToApply);
        console.log(`ğŸ¯ æ•µ${i}ã« ${damageToApply} ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼æ®‹HP: ${enemy.hp}`);
  
        // ğŸŒŸ ã“ã“ã§ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ä½œã‚‹ï¼ˆæ”»æ’ƒæ™‚1å›ã ã‘ï¼‰
      for (let j = 0; j < 30; j++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 0.05 + 0.02;
        const lifetime = 30 + Math.floor(Math.random() * 30);
        particles.push(new Particle(enemy.x, enemy.y, angle, speed, lifetime));
        //particles.push(new Particle(0,0,0,0,99999));
        console.log(`ç²’ä½œæˆ: x=${enemy.x}, y=${enemy.y}, lifetime=${lifetime}`);
      }
  
        if (enemy.hp <= 0) {
          console.log(`ğŸ’€ æ•µ${i} æ’ƒç ´ï¼`);
        }
      }
    });
  
    if (equippedWeapon && equippedWeapon.name.includes("çŸ­å‰£")) {
      console.log("ğŸ—¡ï¸ çŸ­å‰£æ”»æ’ƒç™ºå‹•ã€æ–¬æ’ƒã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºï¼");
      showZangekiEffect();
    } else if (!equippedWeapon) {
      isPunching = true;
      punchTimer = 0;
    }
  }
  //ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ”»æ’ƒé–¢é€£â†‘
  
 
  function showZangekiEffect() {
    const effectDuration = 200; // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆè¡¨ç¤ºæ™‚é–“ï¼ˆmsï¼‰
    const startTime = Date.now();
  
    function drawEffect() {
      const now = Date.now();
      if (now - startTime < effectDuration) {
        // æ”»æ’ƒæ–¹å‘ä¸­å¤®ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¡¨ç¤ºï¼ˆä¾‹: ç”»é¢ä¸­å¤®ï¼‰
        ctx.drawImage(
          zangekiImg,
          canvas.width / 2 - zangekiImg.width / 4,
          canvas.height / 2 - zangekiImg.height / 4,
          zangekiImg.width / 2,
          zangekiImg.height / 2
        );
        requestAnimationFrame(drawEffect);
      }
    }
  
    drawEffect();
  }
  
  
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
}
  

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - angle;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawChargeGauge() {
    if(!isCharging || chargeThreshold === 0)return;

  const width = 100;
  const height = 10;
  const x = canvas.width / 2 - width / 2;
  const y = canvas.height - 40;

  const ratio = Math.min(1, chargeTime / chargeThreshold);

  ctx.fillStyle = "gray";
  ctx.fillRect(x, y, width, height);

  ctx.fillStyle = "lime";
  ctx.fillRect(x, y, width * ratio, height);
}
    

  
  let nearbyItemIndex = -1;

  function updateNearbyItem() {
    nearbyItemIndex = -1; // åˆæœŸåŒ–
  
    items.forEach((item, index) => {
      const dx = item.x - posX;
      const dy = item.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.5) { // è¿‘ã‘ã‚Œã°
        nearbyItemIndex = index;
      }
    });
  }

  function checkNearbyItems() {
    nearbyItemIndex = -1;
    for (let i = 0; i < items.length; i++) {
      const dx = items[i].x - posX;
      const dy = items[i].y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.6) {
        nearbyItemIndex = i; // è¿‘ãã®ã‚¢ã‚¤ãƒ†ãƒ ç•ªå·
        break;
      }
    }
  }
  
  function drawPickupPrompt() {
  if (nearbyItemIndex !== -1) {
    const item = items[nearbyItemIndex]; // ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’å–å¾—

    ctx.fillStyle = "white";
    ctx.font = "84px sans-serif";
    ctx.textAlign = "center";
   // ctx.fillText("ã€æ‹¾ã†ã€‘", canvas.width / 2, canvas.height - 80);
    ctx.fillText(`ã€${item.name}ã€‘`, canvas.width / 2, canvas.height - 580);
  }
}
 
 function drawGameOverScreen() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    ctx.fillStyle = "red";
    ctx.font = "64px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
  
    ctx.fillStyle = "white";
    ctx.font = "24px sans-serif";
    ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 50);
  }
  
  


  
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const halfFov = fov / 2;

    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
  
      //ï¼šãã®æ–¹å‘ã®å£ã¨ã®è·é›¢ã‚’å–å¾—
      let rayAngle = normalizeAngle(angle+ angleToGoal);
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);
      let rayDist = 0;
      let hit = false;
      while (!hit && rayDist < maxDepth) {
        rayDist += 0.01;
        let testX = Math.floor(posX + eyeX * rayDist);
        let testY = Math.floor(posY + eyeY * rayDist);
        if (
          testX < 0 || testY < 0 ||
          testX >= mapWidth || testY >= mapHeight
        ) {
          hit = true;
          rayDist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
  
      // ã‚´ãƒ¼ãƒ«ãŒæ‰‹å‰ã«ã‚ã‚‹ã¨ãã ã‘æç”»
      if (dist < rayDist) {
        const maxSize = 180;
        const size = Math.max(4, maxSize / dist);
        
        ctx.fillStyle = "lime";
        ctx.font = `${size}px sans-serif`; // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼è¦‹ãŸç›®ã®å¤§ãã•
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("éš", screenX, canvas.height / 2);

      }
    }
  }
  
  let goalInRange = false;
  
  function updateGoalProximity() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    goalInRange = dist < 0.5;
  }
  
  
  function checkGoalCharging() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const isInGoalArea = dist < 0.5;
  
    if (isInGoalArea && charging && !isCharging) {
      startCharge(() => {
        floor++;
        console.log("æ¬¡ã®éšå±¤ã¸ï¼");
        initNextFloor(); // å¿…è¦ãªã‚‰ã“ã“ã§éšå±¤é·ç§»å‡¦ç†
      }, 100); // 100ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„1.6ç§’ï¼‰ãªã©
    }
  }
  
  function initNextFloor() {
  map = generateRandomMap(16, 16);
  goal = findRandomEmptyTile(map);

  explored = Array.from({ length: map.length }, () =>
    Array.from({ length: map[0].length }, () => false)
  );

  posX = 1.5;
  posY = 1.5;

  carvePath(map, { x: posX, y: posY }, goal);

  const itemNames = [
    "ğŸ—¡ï¸çŸ­å‰£",
    "ğŸãƒ‘ãƒ³",
    "ğŸ’Šå›å¾©è–¬",
    "ğŸ’Šéˆè¶³ã®è–¬",
    "ğŸ’Šä¿Šè¶³ã®è–¬"
  ];

  // ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆ
  items.length = 0;
  for (let i = 0; i < 5; i++) {
    const tile = findRandomEmptyTile(map);
    const name = itemNames[Math.floor(Math.random() * itemNames.length)];
    let type = "misc";
    let damage = 0;
    let heal = 0;

    if (name.includes("å›å¾©è–¬")) {
      type = "medicine";
      heal = 20;
    }
    else if (name.includes("ãƒ‘ãƒ³")) type = "food";
    else if (name.includes("çŸ­å‰£")) {
      type = "weapon";
      damage = 5;
    }

    items.push(new Item(
      tile.x,
      tile.y,
      name,
      type,
      name.includes("çŸ­å‰£") ? 1.0 : 2.5,
      damage,
      heal
    ));
  }

  // æ•µã®ãƒªã‚»ãƒƒãƒˆ
  enemies = [];
  //spawnEnemies(5);
  
  
  /*
  if (floor === 3){
    const tile = findRandomEmptyTile(map);
    enemies.push(new MummyEnemy(tile.x,tile.y));
  }
}
*/
  

  // ã‚¾ãƒ³ãƒ“ã‚’é…ç½®ï¼ˆ1éšã€œ3éšï¼‰
  if (floor >= 1 && floor <= 3) {
    spawnEnemies(5); // ã‚¾ãƒ³ãƒ“5ä½“
  }

  // ãƒŸã‚¤ãƒ©ã‚’é…ç½®ï¼ˆ3éšã€œ5éšï¼‰
  if (floor >= 3 && floor <= 5) {
    const mummyCount = 3 + Math.floor((floor - 3) * 1); // 3F=1ä½“, 4F=2ä½“, 5F=3ä½“
    for (let i = 0; i < mummyCount; i++) {
      const tile = findRandomEmptyTile(map);
      enemies.push(new MummyEnemy(tile.x, tile.y));
    }
    console.log(`éš${floor}: ãƒŸã‚¤ãƒ©ç”· ${mummyCount}ä½“ã‚’é…ç½®ï¼`);
  }
  
  //ãƒ‰ãƒ©ã‚´ãƒ³é…ç½®ï¼•éš
    if (floor === 5) {
    const dragonCount = 1
    for (let i = 0; i < dragonCount; i++) {
      const tile = findRandomEmptyTile(map);
      enemies.push(new DragonEnemy(tile.x, tile.y));
    }
    console.log(`éš${floor}: dragon ${dragonCount}ä½“ã‚’é…ç½®ï¼`);
  }


  }
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  }
  
  let goalReached = false;
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (angle - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // è·é›¢ã«å¿œã˜ã¦å£ã®é«˜ã•ã‚’èª¿æ•´ï¼ˆé ã„ã»ã©å°ã•ãï¼‰
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }
  
  function drawUseBox() {
    const size = 100; // æ­£æ–¹å½¢ã®ã‚µã‚¤ã‚º
    const x = canvas.width - size - 20; // å³ã‹ã‚‰20pxå†…å´
    const y = canvas.height / 1.75 - size / 2; // ç¸¦ä¸­å¤®ã«é…ç½®
  
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, size, size);
    
   

    // è£…å‚™ä¸­æ­¦å™¨ã®ã‚¢ã‚¤ã‚³ãƒ³
    if (equippedWeapon) {
      ctx.font = `${size * 0.5}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ğŸ—¡ï¸", x + size / 2, y + size / 2);
    }

  }
  
  function isInUseBox(touchX, touchY) {
    const size = 100;
    const x = canvas.width - size - 20;
    const y = canvas.height / 1.75 - size / 2;
    return (
      touchX >= x &&
      touchX <= x + size &&
      touchY >= y &&
      touchY <= y + size
    );
  }
  
  function getDirectionName(angle) {
    const angleDeg = (angle * 180 / Math.PI + 360) % 360;
  
    //if (angleDeg >= 22.5 && angleDeg < 67.5) return "å—æ±â†˜";
    if (angleDeg >= 67.5 && angleDeg < 112.5) return "Sâ†“";
    //if (angleDeg >= 112.5 && angleDeg < 157.5) return "å—è¥¿â†™";
    if (angleDeg >= 157.5 && angleDeg < 202.5) return "Wâ†";
    //if (angleDeg >= 202.5 && angleDeg < 247.5) return "åŒ—è¥¿â†–";
    if (angleDeg >= 247.5 && angleDeg < 292.5) return "Nâ†‘";
    //if (angleDeg >= 292.5 && angleDeg < 337.5) return "åŒ—æ±â†—";
    return "Eâ†’";
  }
  
  function drawDirectionHUD() {
    const direction = getDirectionName(angle); // angleã¯ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã¨ä»®å®š
    ctx.font = "80px sans-serif";
    ctx.fillStyle = "White";
    ctx.fillText(`${direction}`, 10, 200);
  }
  
  function drawEnemyWarning(angleToEnemy) {
    const blink = Math.floor(warningTimer / 30) % 2 === 0;
    if (!blink) return;
  
    ctx.save();
    ctx.fillStyle = "red";
    ctx.font = "180px sans-serif";
    ctx.textAlign = "center";
  
    const normalized = normalizeAngle(angleToEnemy - angle);
    if (normalized < 0) {
      ctx.fillText("ï¼œï¼œï¸", 80, canvas.height / 2);
    } else {
      ctx.fillText("ï¼ï¼ï¸", canvas.width - 80, canvas.height / 2);
    }
  
    ctx.restore();
  }

  function render() {
    ctx.save();
  
    // âœ… ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚·ã‚§ã‚¤ã‚¯
    if (shakeTimer > 0) {
      const dx = (Math.random() - 0.5) * shakeIntensity;
      const dy = (Math.random() - 0.5) * shakeIntensity;
      ctx.translate(dx, dy);
      shakeTimer--;
    }
  
    // â‘  èƒŒæ™¯
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    // â‘¡ ã‚²ãƒ¼ãƒ ä¸–ç•Œï¼ˆå£ãƒ»æ•µãƒ»ã‚¢ã‚¤ãƒ†ãƒ ãƒ»ã‚´ãƒ¼ãƒ«ãªã©ï¼‰
    castRays();
    drawItems();
  
    for (const enemy of enemies) {
      if (enemy.isAlive) {
        enemy.updateHitEffect();
        enemy.drawFromRaycastView(ctx);
  
        const dx = enemy.x - posX;
        const dy = enemy.y - posY;
        const distance = Math.hypot(dx, dy);
        const angleToEnemy = Math.atan2(dy, dx);
        const diff = Math.abs(normalizeAngle(angleToEnemy - angle));
  
        const isNearby = distance < 1.5;
        const isOutsideFov = diff > fov / 2;
  
        if (isNearby && isOutsideFov) {
          drawEnemyWarning(angleToEnemy);
        }
      }
    }
  
    enemies.forEach(enemy => {
      if (enemy.isAlive) {
        enemy.updateHitEffect();
      }
    });
  
    drawGoal();
  
    // â‘¢ UI
    drawChargeGauge();
    drawStatusBars();
    drawPickupPrompt();
    drawInventory();
    drawMiniMap();
    drawPunchEffect();
    drawSelectedItem();
    drawDraggedItem();
    drawUseBox();
    drawFullDropZones();
    drawDirectionHUD();
  
    ctx.fillStyle = "white";
    ctx.font = "44px sans-serif";
    ctx.fillText(`${floor}F`, 200, 30);
  
    ctx.font = "20px sans-serif";
    ctx.fillText(`Count: ${gameCount}`, canvas.width - 150, 30);
  
    if (isGameOver) drawGameOverScreen();
  
    // ğŸ‡ ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã¯ä¸€ç•ªæœ€å¾Œã«æã
    for (const p of particles) {
      p.draw(ctx);
    }
  
    ctx.restore();
  }
  
  
  let isCharging = false;
  let chargeTime = 0;
  let chargeCallback = null;
  
  let showDropTargets = false;


//2025/06/08ã‚¢ã‚¤ãƒ†ãƒ 
  startCharge(() => {
    const item = items[nearbyItemIndex];
    inventory.push(item); // æ‰€æŒå“ã«è¿½åŠ 
    items.splice(nearbyItemIndex, 1); // ãƒãƒƒãƒ—ä¸Šã‹ã‚‰å‰Šé™¤
    nearbyItemIndex = -1;
    isDraggingItem = false;
  }, 60);

  function startCharge(callback, threshold = 60) {
    
    if(isCharging){
      console.log("ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒ£ãƒ¼ã‚¸å®Ÿè¡Œ",{threshold});
      return;
    }
      isCharging = true;
      chargeTime = 0;
      chargeCallback = callback;
      chargeThreshold = threshold;
  }
  
  function stopCharge() {
    isCharging = false;
    chargeTime = 0;
    chargeCallback = null;
    isDraggingItem = false;
  }


  function updateCharge() {
    if (isCharging && chargeCallback) {
      chargeTime++;
      if (chargeTime >= chargeThreshold) {
        chargeCallback(); // æˆåŠŸæ™‚ã®å‡¦ç†ã‚’å®Ÿè¡Œ
        stopCharge();     // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
      }
    }else{
    }
  }
  
 function move(forward) {
  const moveSpeed = forward ? 0.04 : -0.02;
  const nextX = posX + Math.cos(angle) * moveSpeed;
  const nextY = posY + Math.sin(angle) * moveSpeed;

  // å£ãƒã‚§ãƒƒã‚¯
  if (map[Math.floor(nextY)][Math.floor(nextX)] !== 0) return;

  // æ•µã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
  let blocked = false;

  for (const enemy of enemies) {
    if (!enemy.isAlive) continue;
    const dx = enemy.x - nextX;
    const dy = enemy.y - nextY;
    const dist = Math.hypot(dx, dy);

    const angleToEnemy = Math.atan2(dy, dx);
    const diffAngle = Math.abs(normalizeAngle(angleToEnemy - angle));
    const frontAngleThreshold = Math.PI / 2;

    // âœ… å‰æ–¹ã®æ•µã®ã¿ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆèƒŒå¾Œã¯ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ï¼‰
    if (dist < 0.4 && diffAngle < frontAngleThreshold) {
      blocked = true;
      break;
    }
  }

  if (blocked) {
    if (!forward) {
      // âœ… å¾Œé€€æ™‚ã¯ã‚¹ãƒ”ãƒ¼ãƒ‰ãã®ã¾ã¾ã€å£è¡çªã ã‘ãƒã‚§ãƒƒã‚¯ã—ã¦ç§»å‹•è¨±å¯
      const escapeX = posX + Math.cos(angle) * moveSpeed;
      const escapeY = posY + Math.sin(angle) * moveSpeed;
      if (map[Math.floor(escapeY)][Math.floor(escapeX)] === 0) {
        posX = escapeX;
        posY = escapeY;
      }
    }
    return;
  }

  // âœ… æ­£å¸¸ç§»å‹•
  posX = nextX;
  posY = nextY;
}
  
  /*
  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(angle) * moveSpeed;
    const nextY = posY + Math.sin(angle) * moveSpeed;
  
    // â‘  å£ãƒã‚§ãƒƒã‚¯
    if (map[Math.floor(nextY)][Math.floor(nextX)] !== 0) return;
  
    // â‘¡ æ•µã¨ã®è¡çªãƒã‚§ãƒƒã‚¯
    for (const enemy of enemies) {
      if (!enemy.isAlive) continue;
      const dx = enemy.x - nextX;
      const dy = enemy.y - nextY;
      const dist = Math.hypot(dx, dy);
      if (dist < 0.4) return; // âœ‹ è¿‘ã™ãã‚‹ã®ã§ç§»å‹•ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«
  }
 // â‘¢ OKãªã‚‰ç§»å‹•
  posX = nextX;
  posY = nextY;
}*/


  function rotate(deltaAngle) {
    angle += deltaAngle;
    angle =  normalizeAngle(angle);
  }
  
  
  function gameLoop() {
  warningTimer++;
  gameCount++;

  // ç”»é¢ã‚¯ãƒªã‚¢ã¯æœ€åˆã«1å›ã ã‘
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // å„ç¨®å‡¦ç†
  getDirectionName();
  
  

  // æ•µã®æ›´æ–°ãƒ»æç”»
  for (let i = enemies.length - 1; i >= 0; i--) {
    const enemy = enemies[i];
    enemy.update(posX, posY);
    enemy.updateHitEffect();
    if (enemy.isDying && enemy.alpha <= 0) {
      console.log("ğŸ’€ æ•µæ¶ˆæ»… å®Œäº†");
      enemies.splice(i, 1);
    }
  }
  
  // è¡€ã—ã¶ãã‚’æ›´æ–°
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    if (!particles[i].isAlive()) {
      particles.splice(i, 1);
    }
  }
  

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ãƒ»å›è»¢
  if (!isDraggingItem) {
    if (isMovingForward) move(true);
    if (isMovingBackward) move(false);
    if (isTurningLeft) rotate(-0.05);
    if (isTurningRight) rotate(0.05);
  }

  // ãã®ä»–ã®æ›´æ–°ãƒ»æç”»
  updateGoalProximity();
  checkNearbyItems();
  checkGoalCharging();
  updateNearbyItem();
  updateCharge();
  playerHunger();
  render();  // ã“ã“ã§ç”»é¢å…¨ä½“ã‚’å†æç”»ã™ã‚‹å ´åˆã€æ•µã®æç”»ã®å¾Œã«å‘¼ã°ãªã„ã‚ˆã†ã«èª¿æ•´ãŒå¿…è¦

  // æ¢ç´¢è¨˜éŒ²
  explored[Math.floor(posY)][Math.floor(posX)] = true;

  ctx.restore();

  if (player.hp <= 0) {
    isGameOver = true;
    return;
  }

  requestAnimationFrame(gameLoop);
}
  
  
  
  
  
   document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });
  
  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft": rotate(-0.05); break;
      case "ArrowRight": rotate(0.05); break;
      case "ArrowUp": move(true); break;
      case "ArrowDown": move(false); break;
      case " ": shoot(); break; // â† ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å¼¾ç™ºå°„ï¼
    }
  });
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // â†å·¦å›è»¢ãƒ•ãƒ©ã‚°
    let isTurningRight = false;  // â†å³å›è»¢ãƒ•ãƒ©ã‚°
    let touchStartY = null;
    let touchStartX = null;
    
    //let draggingItem = false;
    let dragX = 0;
    let dragY = 0;
    
    let inventoryTouchStartY = null;
    let isInventorySwipeAllowed = false;
    
    let isDraggingItem = false;
    let wasDraggingItem = false;
 
    let isSwipeAllowed = false;
    
    
    
    canvas.addEventListener("touchstart", (e) => {
      
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const yInCanvas = touch.clientY - rect.top;
  
  

  touchStartY = touch.clientY;
  touchStartX = touch.clientX;
  inventoryTouchStartY = touch.clientY;
  isInventorySwipeAllowed = yInCanvas < canvas.height - 200;

  const item = player.inventory[selectedInventoryIndex];
  const textX = canvas.width / 2 - 40;
  const textY = canvas.height - 60;
  const dist = Math.hypot(touch.clientX - textX, touch.clientY - textY);
  



  // ğŸ’ ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹åˆ¤å®š
  if (item && dist < 100) {
    isDraggingItem = true;
    wasDraggingItem = true;
    dragX = touch.clientX;
    dragY = touch.clientY;
    console.log("ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹",dragX,dragY,  "isDraggingItem:", isDraggingItem);
    render(); // å³æç”»
    return;
  }
  
  
  if (isInUseBox(touch.clientX, touch.clientY) && equippedWeapon) {
      // è£…å‚™è§£é™¤
      console.log(`âš”ï¸ è£…å‚™è§£é™¤: ${equippedWeapon.name}`);
      player.inventory.push(equippedWeapon); // ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã«æˆ»ã™
      isDraggingItem = true;
      wasDraggingItem = true;
      selectedInventoryIndex = player.inventory.length - 1; // æ–°ãŸã«è¿½åŠ ã—ãŸæ­¦å™¨
      equippedWeapon = null;
  }
  
  
  // æ”»æ’ƒå‡¦ç†ï¼ˆãƒ‰ãƒ©ãƒƒã‚°ã˜ã‚ƒãªã„ã€ã‹ã¤ãƒãƒ£ãƒ¼ã‚¸ã—ã¦ãªã„ã¨ãï¼‰
  if (!isDraggingItem && !charging) {
    const now = Date.now();
    if (now - lastAttackTime > attackCooldown) {
      lastAttackTime = now;
    }
  }

  // ğŸŸ¢ ã‚¢ã‚¤ãƒ†ãƒ å–å¾— or ã‚´ãƒ¼ãƒ«ãƒãƒ£ãƒ¼ã‚¸
  if (nearbyItemIndex !== -1) {
    
    startCharge(() => {
      player.inventory.push(items[nearbyItemIndex]);
      items.splice(nearbyItemIndex, 1);
      nearbyItemIndex = -1;
    }, 60);
  } else if (goalInRange) {
    startCharge(() => {
      floor++;
      initNextFloor();
    }, 100);
  }


  // ğŸ® ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
  if (isGameOver) location.reload();

}, { passive: true });
    

    
    canvas.addEventListener("touchmove", (e) => {
  if (isDraggingItem) {
    const touch = e.touches[0];
    dragX = touch.clientX;
    dragY = touch.clientY;
    //console.log("ãƒ‰ãƒ©ãƒƒã‚°ä¸­",dragX,dragY,isDraggingItem);
    


    return; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ä»–å‡¦ç†ç„¡è¦–
  }

  if (touchStartY === null || touchStartX === null) return;

  const touchY = e.touches[0].clientY;
  const touchX = e.touches[0].clientX;

  const dy = touchStartY - touchY;
  const dx = touchX - touchStartX;

  // å‰é€²ãƒ»å¾Œé€€
  if (dy > 50) {
    isMovingForward = true;
    isMovingBackward = false;
  } else if (dy < -50) {
    isMovingForward = false;
    isMovingBackward = true;
  }

  // å›è»¢
  if (dx > 50) {
    isTurningRight = true;
    isTurningLeft = false;
    rotate(0.2);
    touchStartX = touchX;
  } else if (dx < -50) {
    isTurningLeft = true;
    isTurningRight = false;
    rotate(-0.2);
    touchStartX = touchX;
  }
}, { passive: false });

const TAP_THRESHOLD = 10;

canvas.addEventListener("touchend", (e) => {
  const touchEndX = e.changedTouches[0].clientX;
  const touchEndY = e.changedTouches[0].clientY;
  const dx = touchEndX - touchStartX;
  const dy = touchEndY - touchStartY;
  const distance = Math.hypot(dx, dy);

  // ãƒ‡ãƒãƒƒã‚°æƒ…å ±
  const angleDeg = angle * 180 / Math.PI;
  //console.log(`ğŸ§­ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä»Š ${angleDeg.toFixed(1)}Â° ã®æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹`);
  //console.log("ğŸ“ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®: X =", posX.toFixed(2), "Y =", posY.toFixed(2));

  if (wasDraggingItem) {
    console.log("ğŸŸ¢ ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†ã«ã¯ã„ã‚Šã¾ã—ãŸ");
    const x = touchEndX;
    const y = touchEndY;
    const w = canvas.width / 2;
    const h = canvas.height / 2;

    let action = null;
    if (x < w && y < h) action = "throw";
    else if (x >= w && y < h) action = "use";
    else if (x < w && y >= h) action = "drop";

    console.log("ğŸ“ æœ€çµ‚ä½ç½®:", x, y, "â¡ï¸ Action:", action);

    const item = player.inventory[selectedInventoryIndex];
    if (item) {
      if (isInUseBox(touchEndX, touchEndY)) {
        handleDrop(item, "usebox");
      } else {
        switch (action) {
          case "throw":
            console.log("ğŸ’¥ æŠ•ã’ãŸï¼");
            break;
          case "drop":
            console.log("ğŸ“¦ åœ°é¢ã«ç½®ã„ãŸï¼");
            items.push(new Item(posX, posY, item.name, item.type, item.weight));
            player.inventory.splice(selectedInventoryIndex, 1);
            break;
          case "use":
            console.log("âœ… ä½¿ç”¨ã—ãŸï¼");
            useSelectedItem();
            break;
          default:
            console.log("ğŸ‘† ä½•ã‚‚ã—ãªã„ã‚¨ãƒªã‚¢ã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸ");
            break;
        }
      }
    }

    // ãƒ‰ãƒ©ãƒƒã‚°å¾Œã®åˆæœŸåŒ–
    isDraggingItem = false;
    wasDraggingItem = false;
    showDropTargets = false;
    tapHandled = true;

    return; // ä»–ã®å‡¦ç†ã«é€²ã¾ãªã„
  }

  // ğŸ‘Š ã‚¿ãƒƒãƒ—ã«ã‚ˆã‚‹æ”»æ’ƒåˆ¤å®š
  if (distance < TAP_THRESHOLD) {
    performAttack();
  }



  // --- ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒ¯ã‚¤ãƒ—å‡¦ç† ---
  if (inventoryTouchStartY !== null && isInventorySwipeAllowed) {
    const endY = e.changedTouches[0].clientY;
    const diffY = endY - inventoryTouchStartY;

    if (Math.abs(diffY) > 50) {
      selectedInventoryIndex += diffY > 0 ? 1 : -1;
      const len = player.inventory.length;
      selectedInventoryIndex = len > 0 ? (selectedInventoryIndex + len) % len : 0;
    }
  }

  inventoryTouchStartY = null;
  isInventorySwipeAllowed = false;
  
   // --- å…±é€šãƒªã‚»ãƒƒãƒˆï¼ˆãƒ‰ãƒ­ãƒƒãƒ—å¾Œã«ã™ã‚‹ï¼‰
  isMovingForward = false;
  isMovingBackward = false;
  isTurningLeft = false;
  isTurningRight = false;
  touchStartY = null;
  touchStartX = null;
  stopCharge();
});



  
  gameLoop();
  </script>
  
  </body>
  </html>



  

