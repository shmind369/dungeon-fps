<!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯FPS</title>
    <style>
      body {
        margin: 0;
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
   
  </head>
  <body>
 
  <canvas id="gameCanvas"></canvas>
  <script>
  //
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  
  let player = {
    hp: 100,
    maxHp: 100,
    hunger: 100,
    maxHunger: 100,
    inventory: [],
    effects: []  // çŠ¶æ…‹ç•°å¸¸ãªã©
  };
  

  
  let isGameOver = false;
  
  let selectedInventoryIndex = 0; //é¸æŠä¸­ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹(ä»®)

  
  // ã“ã“ã§ãƒãƒƒãƒ—ã¨ã‚´ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
  let map = generateRandomMap(16, 16);
  let goal = findRandomEmptyTile(map);
    
  let explored = [];
  
      for (let y = 0; y < map.length; y++) {
        explored[y] = [];
      for (let x = 0; x < map[0].length; x++) {
        explored[y][x] = false; // ã¾ã æ¢ç´¢ã—ã¦ã„ãªã„
      }
    }
    
    const start = {x:1.5,y:1.5};
    
    carvePath(map,start,goal);
    let posX = start.x;
    let posY = start.y;
  
  //ãƒ•ãƒ­ã‚¢ã®èª¿æ•´
  let floor = 1;
  
  
  const bullets = [];
  
  

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
 
  let angle = 0;
  
  
  //ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚²ãƒ¼ã‚¸
  let charging = false;
  //let chargeTime = 0;
  let chargeThreshold = 100; // 100ãƒ•ãƒ¬ãƒ¼ãƒ ã§æº€ã‚¿ãƒ³
  //ã“ã“ã¾ã§

  //let posX = 3.5, posY = 3.5; angle = 0;// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
  let dir = 0; // è¦–ç‚¹ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  

  const inventory = [];
  
    

    // 1. ã‚¢ã‚¤ãƒ†ãƒ åã‚’å®šç¾©ï¼ˆ5ã€œ6ç¨®é¡ï¼‰
  const itemNames = ["ğŸ—¡ï¸é’éŠ…å‰£", "ğŸãƒ‘ãƒ³", "ğŸ•¯ï¸æ¾æ˜", "ğŸ¹æœ¨ã®çŸ¢", "ğŸ”‘éµ", "ğŸ’Šå›å¾©è–¬","ğŸ’Šéˆè¶³ã®è–¬","ğŸ’Šä¿Šè¶³ã®è–¬"];
  
  
  // 2. ã‚¢ã‚¤ãƒ†ãƒ ã”ã¨ã«ãƒ©ãƒ³ãƒ€ãƒ ãªåå‰ã‚’å‰²ã‚Šå½“ã¦ï¼ˆåˆæœŸåŒ–æ™‚ï¼‰
  const items = Array.from({ length: 10 }, () => ({
    x: Math.floor(Math.random() * 14) + 1.5,
    y: Math.floor(Math.random() * 14) + 1.5,
    name: itemNames[Math.floor(Math.random() * itemNames.length)]
  }));
  
  
  const fov = Math.PI / 3; // 60åº¦è¦–é‡è§’
  //const numRays = canvas.width;
  // ä¾‹: ãƒ¬ã‚¤æœ¬æ•°ã‚’åˆ¶é™
  const numRays = Math.min(1024, canvas.width); // ç”»è³ªè½ã¡ã‚‹ã‘ã©è»½ããªã‚‹
  
  const maxDepth = 10;
  
  let enemyX = 5.5;
  let enemyY = 1.5;
  
  let enemyColor = "red";
  let enemyHitTimer = 0;
  let enemyHP = 3;
  
    function generateRandomMap(width, height) {
  const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // å¤–å‘¨ã¯å£
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
        }
      }
      newMap.push(row);
    }
    return newMap;
  }


  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
      }
    }
  }
  

  
  
  function carvePath(map, start, goal) {
    let x = Math.floor(start.x);
    let y = Math.floor(start.y);
    const gx = Math.floor(goal.x);
    const gy = Math.floor(goal.y);
  
    while (x !== gx || y !== gy) {
      map[y][x] = 0; // é“ã‚’æ˜ã‚‹
  
      if (Math.random() < 0.5 && x !== gx) {
        x += gx > x ? 1 : -1;
      } else if (y !== gy) {
        y += gy > y ? 1 : -1;
      }
    }
  }
  
  function drawMiniMap() {
  const scale = 10;
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  // ğŸ”§ èƒŒæ™¯ã‚’ç™½ã«å¡—ã‚‹ï¼ˆå·¦ä¸Šã«æç”»ï¼‰
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue;

      ctx.fillStyle = (map[y][x] === 1) ? "gray" : "black";
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ï¼ˆé’ï¼‰
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);
  
 
}
  
  function drawStatusBars() {
    const barWidth = 200;
    const barHeight = 16;
    const margin = 20;
  
    // HPãƒãƒ¼
    const hpRatio = player.hp / player.maxHp;
    ctx.fillStyle = "orange";
    ctx.fillRect(margin, canvas.height - barHeight * 2 - margin, barWidth * hpRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight * 2 - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`HP: ${player.hp}/${player.maxHp}`, margin + 5, canvas.height - barHeight * 2 - margin + 12);
  
    // æº€è…¹åº¦ãƒãƒ¼
    const hungerRatio = player.hunger / player.maxHunger;
    ctx.fillStyle = "green";
    ctx.fillRect(margin, canvas.height - barHeight - margin, barWidth * hungerRatio, barHeight);
    ctx.strokeStyle = "white";
    ctx.strokeRect(margin, canvas.height - barHeight - margin, barWidth, barHeight);
    ctx.fillStyle = "white";
    ctx.font = "12px sans-serif";
    ctx.fillText(`æº€è…¹åº¦: ${player.hunger}/${player.maxHunger}`, margin + 5, canvas.height - barHeight - margin + 12);
  }

  function drawInventory() {
    
  const padding = 20;            // å³ç«¯ãƒ»ä¸Šç«¯ã‹ã‚‰ã®ä½™ç™½
  const lineHeight = 24;         // è¡Œé–“
  const fontSize = 40;

  const x = canvas.width - 200;  // â† å¸¸ã«å³ç«¯ï¼ˆç”»é¢å¹…ã‹ã‚‰200pxåˆ†å·¦ã¸ï¼‰
  let y = padding + fontSize;    // ä¸Šç«¯ã‹ã‚‰ä½™ç™½ã‚’å–ã£ã¦é–‹å§‹ä½ç½®

  ctx.fillStyle = "white";
  ctx.font = `${fontSize}px sans-serif`;
  ctx.textAlign = "left";
  ctx.textBaseline = "top";

  ctx.fillText("ğŸ’ ITEM", x, y);
  y += lineHeight;

  player.inventory.forEach((item, index) => {
    const itemText = item?.name || "(ä¸æ˜ãªã‚¢ã‚¤ãƒ†ãƒ )";
    ctx.fillText(`- ${itemText}`, x, y + index * lineHeight);
      if (item && item.name) {
      ctx.fillStyle = index === selectedInventoryIndex ? "yellow" : "white";
      ctx.fillText(`- ${item.name}`, x, y + index * 20);
    }
  });
}

  function drawSelectedItem() {
    if (player.inventory.length > 0) {
      const selectedItem = player.inventory[selectedInventoryIndex];
      if (selectedItem && selectedItem.name) {
        ctx.fillStyle = "white";
        ctx.font = "28px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText(`ğŸ¯ ${selectedItem.name}`, canvas.width / 2, canvas.height - 40);
      }
    }
  }
  
  function drawDraggedItem() {
    if (draggingItem) {
      const item = player.inventory[selectedInventoryIndex];
      if (!item) return;
  
      ctx.fillStyle = "yellow";
      ctx.font = "28px sans-serif";
      ctx.fillText(item.name, dragX, dragY);
    }
  }

  
  const enemyBullets = [];
  
  let enemyShootCooldown = 0;

  function enemyShootAtPlayer() {
    if (enemyHP <= 0) return;
  
    if (enemyShootCooldown <= 0) {
      const dx = posX - enemyX;
      const dy = posY - enemyY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const speed = 0.05;
  
      enemyBullets.push({
        x: enemyX,
        y: enemyY,
        dx: dx / dist * speed,
        dy: dy / dist * speed,
        life: 100
      });
  
      enemyShootCooldown = 120; // 2ç§’ã«1å›æ’ƒã¤ï¼ˆ60fpsãªã‚‰120ãƒ•ãƒ¬ãƒ¼ãƒ ï¼‰
    } else {
      enemyShootCooldown--;
    }
  }
  
  function updateEnemyBullets() {
    for (let i = enemyBullets.length - 1; i >= 0; i--) {
      const b = enemyBullets[i];
      b.x += b.dx;
      b.y += b.dy;
      b.life--;
  
      // å£ã§æ¶ˆãˆã‚‹
      if (map[Math.floor(b.y)][Math.floor(b.x)] !== 0 || b.life <= 0) {
        enemyBullets.splice(i, 1);
        continue;
      }
  
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å½“ãŸã‚Šåˆ¤å®š
      const dx = b.x - posX;
      const dy = b.y - posY;
      if (Math.sqrt(dx * dx + dy * dy) < 0.4) {
        player.hp -= 25;  // è¢«å¼¾ã§ãƒ€ãƒ¡ãƒ¼ã‚¸
        enemyBullets.splice(i, 1);
      }
    }
  }
  
  function drawEnemyBullets() {
    enemyBullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        const size = Math.max(2, 30 / dist);
        ctx.fillStyle = "magenta";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  //å¼¾
  function shoot() {
  const bulletSpeed = 0.2;
    bullets.push({
      x: posX,
      y: posY,
      dx: Math.cos(dir) * bulletSpeed,
      dy: Math.sin(dir) * bulletSpeed,
      life: 10  // å¯¿å‘½ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
    });
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.dx;
      b.y += b.dy;
      b.life--;
      
          // å¼¾ã¨æ•µã®è·é›¢ã‚’è¨ˆç®—ã—ã¦å½“ãŸã‚Šåˆ¤å®š
      const dx = b.x - enemyX;
      const dy = b.y - enemyY;
      const distToEnemy = Math.sqrt(dx * dx + dy * dy);
      if (distToEnemy < 0.3) { // â† å‘½ä¸­åˆ¤å®šï¼ˆ0.3ãƒã‚¹ä»¥å†…ï¼‰
        bullets.splice(i, 1); // å¼¾ã‚’æ¶ˆã™
        enemyHP--;
        enemyColor = "orange"; // æ•µã®è‰²ã‚’å¤‰ãˆã‚‹
        enemyHitTimer = 30; // è‰²å¤‰åŒ–æŒç¶šæ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
        
        if(enemyHP <= 0){
          enemyHP = 0;
          enemyX = -1000;
          enemyY = -1000;
        }
        continue;
      }
  
      // å£ã«å½“ãŸã‚‹ or å¯¿å‘½çµ‚äº†ã§å‰Šé™¤
      const mapX = Math.floor(b.x);
      const mapY = Math.floor(b.y);
        if (b.life <= 0 || map[mapY][mapX] !== 0) {
          bullets.splice(i, 1);
        }
    }
  }
  
  let hungerTick = 0;
  
  function playerHunger(){

      hungerTick++;
    if (hungerTick % 240 === 0) { // ç´„4ç§’ã«1å›
      player.hunger -= 1;
      if (player.hunger < 0) player.hunger = 0;
    }
  
    // è…¹åº¦ã‚¼ãƒ­ã§HPæ¸›å°‘ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰
    if (player.hunger === 0) {
      player.hp -= 0.05; // å°‘ã—ãšã¤HPã‚‚æ¸›ã‚‹
      if (player.hp < 0) player.hp = 0;
    }
  }

//æ•µ
  function updateEnemy() {
  if (enemyHP <= 0) return;

  const dx = posX - enemyX;
  const dy = posY - enemyY;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist > 0.05) {
    const step = 0.01;
    const nextX = enemyX + (dx / dist) * step;
    const nextY = enemyY + (dy / dist) * step;

    const tileX = Math.floor(nextX);
    const tileY = Math.floor(nextY);

    // å£ã˜ã‚ƒãªã„å ´åˆã®ã¿ç§»å‹•ã•ã›ã‚‹
    if (map[tileY][tileX] === 0) {
      enemyX = nextX;
      enemyY = nextY;
    }
  }

  if (enemyHitTimer > 0) {
    enemyHitTimer--;
    if (enemyHitTimer === 0) {
      enemyColor = "red";
    }
  }
}
  
  function drawEnemy() {
  const dx = enemyX - posX;
  const dy = enemyY - posY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angleToEnemy = Math.atan2(dy, dx) - dir;
  const halfFov = fov / 2;
  
    if (Math.abs(angleToEnemy) < halfFov) {
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(2000, 500 / distance); // è¿‘ã„ã¨å¤§ããã€é ã„ã¨å°ã•ã

      ctx.fillStyle = enemyColor;
      ctx.font = `${size}px sans-serif`; // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼è¦‹ãŸç›®ã®å¤§ãã•
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("æ•µ", screenX, canvas.height / 2);
  
    }
  }
  
  function drawItems() {
  const halfFov = fov / 2;

  items.forEach(item => {
    const dx = item.x - posX;
    const dy = item.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - dir;

    // ãƒ¬ã‚¤ã‚­ãƒ£ã‚¹ãƒˆï¼ˆå£ã¾ã§ã®è·é›¢ï¼‰ã‚’è¨ˆç®—
    let rayDist = 0;
    let hit = false;
    const rayAngle = normalizeAngle(dir + angleToItem);
    const eyeX = Math.cos(rayAngle);
    const eyeY = Math.sin(rayAngle);
    while (!hit && rayDist < maxDepth) {
      rayDist += 0.01;
      const testX = Math.floor(posX + eyeX * rayDist);
      const testY = Math.floor(posY + eyeY * rayDist);
      if (
        testX < 0 || testY < 0 ||
        testX >= mapWidth || testY >= mapHeight
      ) {
        hit = true;
        rayDist = maxDepth;
      } else if (map[testY][testX] > 0) {
        hit = true;
      }
    }

    // ã‚¢ã‚¤ãƒ†ãƒ ãŒæ‰‹å‰ã«ã‚ã‚‹å ´åˆã ã‘æç”»
    if (Math.abs(angleToItem) < halfFov && distance < rayDist) {
      const screenX = (angleToItem + halfFov) / fov * canvas.width;
      const size = Math.max(5, 200 / distance);

      ctx.fillStyle = "gold";
      ctx.font = `${size}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("ç‰©", screenX, canvas.height / 2);
    }
  });
}

  

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawChargeGauge() {
    if(!isCharging || chargeThreshold === 0)return;

  const width = 100;
  const height = 10;
  const x = canvas.width / 2 - width / 2;
  const y = canvas.height - 40;

  const ratio = Math.min(1, chargeTime / chargeThreshold);

  ctx.fillStyle = "gray";
  ctx.fillRect(x, y, width, height);

  ctx.fillStyle = "lime";
  ctx.fillRect(x, y, width * ratio, height);
}
    

  
  let nearbyItemIndex = -1;

  function updateNearbyItem() {
    nearbyItemIndex = -1; // åˆæœŸåŒ–
  
    items.forEach((item, index) => {
      const dx = item.x - posX;
      const dy = item.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.5) { // è¿‘ã‘ã‚Œã°
        nearbyItemIndex = index;
      }
    });
  }

  function checkNearbyItems() {
    nearbyItemIndex = -1;
    for (let i = 0; i < items.length; i++) {
      const dx = items[i].x - posX;
      const dy = items[i].y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 0.6) {
        nearbyItemIndex = i; // è¿‘ãã®ã‚¢ã‚¤ãƒ†ãƒ ç•ªå·
        break;
      }
    }
  }
  
  function drawPickupPrompt() {
  if (nearbyItemIndex !== -1) {
    const item = items[nearbyItemIndex]; // ã‚¢ã‚¤ãƒ†ãƒ æƒ…å ±ã‚’å–å¾—

    ctx.fillStyle = "white";
    ctx.font = "84px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("ã€æ‹¾ã†ã€‘", canvas.width / 2, canvas.height - 80);
    ctx.fillText(`ã€${item.name}ã€‘`, canvas.width / 2, canvas.height - 580);
  }
}
 
 function drawGameOverScreen() {
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  
    ctx.fillStyle = "red";
    ctx.font = "64px sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
  
    ctx.fillStyle = "white";
    ctx.font = "24px sans-serif";
    ctx.fillText("ç”»é¢ã‚’ã‚¿ãƒƒãƒã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ", canvas.width / 2, canvas.height / 2 + 50);
  }
  
  


  
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = Math.atan2(dy, dx) - dir;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const halfFov = fov / 2;

    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
  
      //ï¼šãã®æ–¹å‘ã®å£ã¨ã®è·é›¢ã‚’å–å¾—
      let rayAngle = normalizeAngle(dir + angleToGoal);
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);
      let rayDist = 0;
      let hit = false;
      while (!hit && rayDist < maxDepth) {
        rayDist += 0.01;
        let testX = Math.floor(posX + eyeX * rayDist);
        let testY = Math.floor(posY + eyeY * rayDist);
        if (
          testX < 0 || testY < 0 ||
          testX >= mapWidth || testY >= mapHeight
        ) {
          hit = true;
          rayDist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
  
      // ã‚´ãƒ¼ãƒ«ãŒæ‰‹å‰ã«ã‚ã‚‹ã¨ãã ã‘æç”»
      if (dist < rayDist) {
        const maxSize = 180;
        const size = Math.max(4, maxSize / dist);
        
        ctx.fillStyle = "lime";
        ctx.font = `${size}px sans-serif`; // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºï¼è¦‹ãŸç›®ã®å¤§ãã•
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("éš", screenX, canvas.height / 2);

      }
    }
  }
  
  let goalInRange = false;
  
  function updateGoalProximity() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    goalInRange = dist < 0.5;
  }
  
  
  function checkGoalCharging() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
  
    const isInGoalArea = dist < 0.5;
  
    if (isInGoalArea && charging && !isCharging) {
      startCharge(() => {
        floor++;
        console.log("æ¬¡ã®éšå±¤ã¸ï¼");
        initNextFloor(); // å¿…è¦ãªã‚‰ã“ã“ã§éšå±¤é·ç§»å‡¦ç†
      }, 100); // 100ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆç´„1.6ç§’ï¼‰ãªã©
    }
  }
  
  function initNextFloor() {
  map = generateRandomMap(16, 16);
  goal = findRandomEmptyTile(map);

  explored = Array.from({ length: map.length }, () =>
    Array.from({ length: map[0].length }, () => false)
  );

  posX = 1.5;
  posY = 1.5;

  carvePath(map, { x: posX, y: posY }, goal);

  // ã‚¢ã‚¤ãƒ†ãƒ ã®ãƒªã‚»ãƒƒãƒˆï¼ˆå¿…è¦ãªã‚‰ï¼‰
  items.length = 0;
  for (let i = 0; i < 5; i++) {
    const tile = findRandomEmptyTile(map);
    items.push({
      x: tile.x,
      y: tile.y,
      name: itemNames[Math.floor(Math.random() * itemNames.length)]
    });
  }

  // æ•µã®ä½ç½®ã‚‚ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãªã‚‰ã“ã“ã§ enemyX/Y ã‚’å¤‰æ›´
  enemyX = 5.5;
  enemyY = 3.5;
  enemyHP = 3;
}
  
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  }
  
  let goalReached = false;
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (dir - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // è·é›¢ã«å¿œã˜ã¦å£ã®é«˜ã•ã‚’èª¿æ•´ï¼ˆé ã„ã»ã©å°ã•ãï¼‰
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }
  
  function drawUseBox() {
    const size = 100; // æ­£æ–¹å½¢ã®ã‚µã‚¤ã‚º
    const x = canvas.width - size - 20; // å³ã‹ã‚‰20pxå†…å´
    const y = canvas.height / 2 - size / 2; // ç¸¦ä¸­å¤®ã«é…ç½®
  
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, size, size);
  }

  function render() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    castRays();
    drawEnemy();
    drawBullets();
    drawItems();
    drawGoal();
    drawChargeGauge();
    drawMiniMap();
    drawStatusBars();
    drawPickupPrompt();
    drawEnemyBullets();
    //drawInventory();
    drawSelectedItem();
    drawUseBox();
    drawDraggedItem();
    
    if(isGameOver)drawGameOverScreen();
    
    ctx.fillStyle = "white";
    ctx.font = "44px sans-serif";
    ctx.fillText(`${floor}F`, 200, 30); // å·¦ä¸Šã«è¡¨ç¤º
    
    drawInventory();
  }
  
  
  let isCharging = false;
  let chargeTime = 0;
  let chargeCallback = null;


//2025/06/08ã‚¢ã‚¤ãƒ†ãƒ 
  startCharge(() => {
    const item = items[nearbyItemIndex];
    inventory.push(item); // æ‰€æŒå“ã«è¿½åŠ 
    items.splice(nearbyItemIndex, 1); // ãƒãƒƒãƒ—ä¸Šã‹ã‚‰å‰Šé™¤
    nearbyItemIndex = -1;
    isDraggingItem = false;
  }, 60);

  function startCharge(callback, threshold = 60) {
    
    if(isCharging){
      console.log("ã‚¹ã‚¿ãƒ¼ãƒˆãƒãƒ£ãƒ¼ã‚¸å®Ÿè¡Œ",{threshold});
      return;
    }
      isCharging = true;
      chargeTime = 0;
      chargeCallback = callback;
      chargeThreshold = threshold;
  }
  
  function stopCharge() {
    isCharging = false;
    chargeTime = 0;
    chargeCallback = null;
    isDraggingItem = false;
  }


  function updateCharge() {
    if (isCharging && chargeCallback) {
      chargeTime++;
      //console.log("ãƒãƒ£ãƒ¼ã‚¸é€²è¡Œä¸­",chargeTime);
      if (chargeTime >= chargeThreshold) {
            //console.log("ãƒãƒ£ãƒ¼ã‚¸å®Œäº†",chargeThreshold);
        chargeCallback(); // æˆåŠŸæ™‚ã®å‡¦ç†ã‚’å®Ÿè¡Œ
        stopCharge();     // çŠ¶æ…‹ãƒªã‚»ãƒƒãƒˆ
      }
    }else{
      //console.log("ãƒãƒ£ãƒ¼ã‚¸ã§ããªã„çŠ¶æ…‹",{isCharging,chargeCallback});
    }
  }

  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(dir) * moveSpeed;
    const nextY = posY + Math.sin(dir) * moveSpeed;
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function rotate(angle) {
    dir += angle;
  }
  
  function gameLoop() {
    
    
    //console.log("isDraggingItem:", isDraggingItem);
    if (!isDraggingItem) {
      if (isMovingForward) move(true);
      if (isMovingBackward) move(false);
      if (isTurningLeft) rotate(-0.05);
      if (isTurningRight) rotate(0.05);
    }
        
    //initNextFloor();
    updateGoalProximity
    checkNearbyItems();
    checkGoalCharging();
    updateNearbyItem();
    updateCharge();
    enemyShootAtPlayer();
    updateEnemyBullets();
    playerHunger();
    render();
    requestAnimationFrame(gameLoop);
    
    
    //console.log(player.hunger);
    
    explored[Math.floor(posY)][Math.floor(posX)] = true;
    //console.log("Enemy position:", enemyX.toFixed(2), enemyY.toFixed(2));
    
    if (player.hp <= 0) {
      
      isGameOver = true;

      
      return;
    }
  
  }
  
   document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });
  
  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft": rotate(-0.05); break;
      case "ArrowRight": rotate(0.05); break;
      case "ArrowUp": move(true); break;
      case "ArrowDown": move(false); break;
      case " ": shoot(); break; // â† ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å¼¾ç™ºå°„ï¼
    }
  });
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // â†å·¦å›è»¢ãƒ•ãƒ©ã‚°
    let isTurningRight = false;  // â†å³å›è»¢ãƒ•ãƒ©ã‚°
    let touchStartY = null;
    let touchStartX = null;
    
    let draggingItem = false;
    let dragX = 0;
    let dragY = 0;
    
    let inventoryTouchStartY = null;
    let isInventorySwipeAllowed = false;
    
    let isDraggingItem = false;
    let isSwipeAllowed = false;
    

    

  //2025/06/10â†“
  canvas.addEventListener("touchstart", (e) => {
    const touch = e.touches[0];
    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®ä½ç½®ã‚’æ­£ç¢ºã«å–å¾—
    const rect = canvas.getBoundingClientRect();
    const yInCanvas = touch.clientY - rect.top;
    const canvasDisplayHeight = rect.height;    // ã‚­ãƒ£ãƒ³ãƒã‚¹ã®è¡¨ç¤ºé«˜ã•
    
    touchStartY = touch.clientY;
    touchStartX = touch.clientX;
    isInventorySwipeAllowed = yInCanvas < canvas.height - 200;
  
      // ãƒ‰ãƒ©ãƒƒã‚°å¯¾è±¡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯
    const item = player.inventory[selectedInventoryIndex];
      if (item) {
        const textX = canvas.width / 2 - 40;
        const textY = canvas.height - 60;
        const dist = Math.hypot(touch.clientX - textX, touch.clientY - textY);
        if (dist < 50) {
          isDraggingItem = true;
          dragX = touch.clientX;
          dragY = touch.clientY;
        }
    }
    
    // ã‚¢ã‚¤ãƒ†ãƒ å–å¾— or ã‚´ãƒ¼ãƒ«ãƒãƒ£ãƒ¼ã‚¸
    if (!isDraggingItem) {
      if (nearbyItemIndex !== -1) {
        startCharge(() => {
          player.inventory.push(items[nearbyItemIndex]);
          items.splice(nearbyItemIndex, 1);
          nearbyItemIndex = -1;
        }, 60);
      } else if (goalInRange) {
        startCharge(() => {
          floor++;
        }, 100);
      }
    }
    
     if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;  // â†æ—¢å­˜ã®Yè¨˜éŒ²ï¼ˆå‰é€²ç”¨ï¼‰
      touchStartX = e.touches[0].clientX;  // â†ğŸ†• å·¦å³å›è»¢ç”¨
    }
    
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;
      charging = true;
    }
    
    if (e.touches.length === 1) {
    inventoryTouchStartY = touch.clientY;
    }
    
    if (e.touches.length === 1) {
      inventoryTouchStartY = e.touches[0].clientY;
    }
    
    //console.log("ã‚¿ãƒƒãƒé–‹å§‹",nearbyItemIndex);
    if (nearbyItemIndex !== -1) {
      startCharge(() => {
        // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—å‡¦ç†
        console.log("ã‚¢ã‚¤ãƒ†ãƒ å–å¾—ï¼");
        player.inventory.push(items[nearbyItemIndex]);
        items.splice(nearbyItemIndex, 1); // æ¶ˆã™
        console.log("ğŸ’ç¾åœ¨ã®ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªï¼š", player.inventory);
        nearbyItemIndex = -1;
      }, 60); // 1ç§’ãã‚‰ã„
    }
      // ã‚´ãƒ¼ãƒ«å‡¦ç†
    else if (goalInRange) {
      startCharge(() => {
        console.log("æ¬¡ã®éšå±¤ã¸ï¼");
        floor++;
        chargeTime = 0;
        //initNextFloor();
        // ã“ã“ã« initNextFloor() ãŒã‚ã‚Œã°å‘¼ã¶
      }, 100); // 1.6ç§’ãã‚‰ã„
    }
    
  
  //const item = player.inventory[selectedInventoryIndex];
  if (!item) return;

  // é¸æŠä¸­ã‚¢ã‚¤ãƒ†ãƒ ã®è¡¨ç¤ºä½ç½®ã‚ãŸã‚Šã‚’ã‚¿ãƒƒãƒã—ãŸã‚‰ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
  const textX = canvas.width / 2 - 40;
  const textY = canvas.height - 60;
  const dist = Math.hypot(touch.clientX - textX, touch.clientY - textY);

  if (dist < 50) { // é©å½“ã«50pxä»¥å†…ãªã‚‰
    draggingItem = true;
    dragX = touch.clientX;
    dragY = touch.clientY;
    console.log("ãƒ‰ãƒ©ãƒƒã‚°ä¸­");
  }
    
  if (selectedInventoryIndex !== null && player.inventory[selectedInventoryIndex]) {
    isDraggingItem = false;
  }
    
    if (isGameOver) {
      location.reload(); // ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ
    }
    
    // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã®å†ã‚¹ã‚¿ãƒ¼ãƒˆ
    if (isGameOver) {
        location.reload();
    }
  }, { passive: true });
  
    
  //2025/06/10â†‘
    
  canvas.addEventListener("touchmove", (e) => {
  const touch = e.touches[0];
  const touchY = touch.clientY;
  const touchX = touch.clientX;

  // --- ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ©ãƒƒã‚°å‡¦ç† ---
  if (draggingItem) {
    dragX = touchX;
    dragY = touchY;
    return; // ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã¯ä»–ã®æ“ä½œã‚’ç„¡åŠ¹ã«ã™ã‚‹ï¼ˆå¿…è¦ãªã‚‰æ®‹ã™ï¼‰
  }

  // --- ã‚¹ãƒ¯ã‚¤ãƒ—æ“ä½œå‡¦ç† ---
  if (touchStartY === null || touchStartX === null) return;

  const dy = touchStartY - touchY;
  const dx = touchX - touchStartX;

  // å‰å¾Œç§»å‹•åˆ¤å®š
  if (dy > 50) {
    isMovingForward = true;
    isMovingBackward = false;
  } else if (dy < -50) {
    isMovingForward = false;
    isMovingBackward = true;
  }

  // å›è»¢ãƒ•ãƒ©ã‚°åˆ¤å®š
  if (dx > 50) {
    isTurningRight = true;
    isTurningLeft = false;
    rotate(0.2); // å›è»¢
    touchStartX = touchX; // é€£ç¶šå›è»¢ã®ãŸã‚æ›´æ–°
  } else if (dx < -50) {
    isTurningLeft = true;
    isTurningRight = false;
    rotate(-0.2); // å›è»¢
    touchStartX = touchX; // é€£ç¶šå›è»¢ã®ãŸã‚æ›´æ–°
  }
}, { passive: true });

  /*
  // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒç§»å‹•ä¸­ã«ä¸€å®šè·é›¢ä¸Šã«å‹•ã„ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°ON
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null) return;
  
    const touchY = e.touches[0].clientY;
    const dy = touchStartY - touchY;
  
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    }else if(dy < -50){
      isMovingForward = false;
      isMovingBackward = true;
    }
  }, { passive: true });
  
  
canvas.addEventListener("touchmove", (e) => {
  if (draggingItem) {
    const touch = e.touches[0];
    dragX = touch.clientX;
    dragY = touch.clientY;
  }
}, { passive: true });
  
  
  
  
  
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null || touchStartX === null) return;
  
    const touchY = e.touches[0].clientY;
    const touchX = e.touches[0].clientX;
  
    const dy = touchStartY - touchY;
    const dx = touchX - touchStartX;
  
    // å‰é€²
    if (dy > 50) {
      isMovingForward = true;
    }
    
    if (dx > 50) {
      isTurningRight = true;      // å³ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
      isTurningLeft = false;
    } else if (dx < -50) {
      isTurningLeft = true;       // å·¦ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
      isTurningRight = false;
    }
  
    // å·¦å³å›è»¢ï¼ˆä¸€å®šè·é›¢å‹•ã‹ã—ãŸã‚‰å›è»¢ï¼‰
    if (dx > 50) {
      rotate(0.2);   // â†’å³ã¸å›è»¢ï¼ˆå³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
      touchStartX = touchX; // â†å›è»¢ã®é€£ç¶šåˆ¤å®šç”¨ã«æ›´æ–°
    } else if (dx < -50) {
      rotate(-0.2);  // â†å·¦ã¸å›è»¢ï¼ˆå·¦ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
      touchStartX = touchX; // â†ã“ã¡ã‚‰ã‚‚æ›´æ–°
    }
  }, { passive: true });
  */

  
  //â†“ã‚¿ãƒƒãƒã‚¨ãƒ³ãƒ‰å‡¦ç†
  
  canvas.addEventListener("touchend", (e) => {
  // --- ãƒ•ãƒ©ã‚°åˆæœŸåŒ– ---
  isMovingForward = false;
  isMovingBackward = false;
  isTurningLeft = false;
  isTurningRight = false;
  touchStartY = null;
  touchStartX = null;
  charging = null;
  chargeTime = 0;

  // --- ãƒãƒ£ãƒ¼ã‚¸ä¸­æ–­å‡¦ç† ---
  stopCharge();

  // --- ãƒ‰ãƒ©ãƒƒã‚°çµ‚äº†åˆ¤å®š ---
  if (draggingItem) {
    const dropX = canvas.width - 70;
    const dropY = canvas.height / 2 - 25;
    const dist = Math.hypot(dragX - dropX, dragY - dropY);
    if (dist < 50) {
      console.log("âœ… ä½¿ç”¨ã‚¹ãƒ­ãƒƒãƒˆã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸï¼");
      // TODO: ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å‡¦ç†ã‚’ã“ã“ã«è¿½åŠ 
    }
    draggingItem = false;
  }

  // --- ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒ¯ã‚¤ãƒ—å‡¦ç† ---
  if (inventoryTouchStartY !== null && isInventorySwipeAllowed) {
    const endY = e.changedTouches[0].clientY;
    const diffY = endY - inventoryTouchStartY;

    if (Math.abs(diffY) > 50) {
      if (diffY > 0) {
        selectedInventoryIndex++;
      } else {
        selectedInventoryIndex--;
      }

      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹
      const len = player.inventory.length;
      if (len > 0) {
        selectedInventoryIndex = (selectedInventoryIndex + len) % len;
      } else {
        selectedInventoryIndex = 0;
      }
    }
  }

  inventoryTouchStartY = null;
  isInventorySwipeAllowed = false;
  isDraggingItem = false;
}, { passive: true });
  
/*
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isTurningLeft = false;
    isTurningRight = false;
    touchStartY = null;
    touchStartX = null;  // ğŸ”§è¿½åŠ ï¼šXæ–¹å‘ã®è¨˜éŒ²ã‚‚ãƒªã‚»ãƒƒãƒˆ
  }, { passive: true });
  
 // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒãŒçµ‚ã‚ã£ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°OFFï¼†ãƒªã‚»ãƒƒãƒˆ
  
  
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isMovingBackward = false;
    touchStartY = null;
    charging = null;
    chargeTime = 0;
  }, { passive: true });

canvas.addEventListener("touchend", (e) => {
  if (!isInventorySwipeAllowed || inventoryTouchStartY === null) return;

  const endY = e.changedTouches[0].clientY;
  const diffY = endY - inventoryTouchStartY;

  if (Math.abs(diffY) > 50) {
    if (diffY > 0) {
      selectedInventoryIndex++;
    } else {
      console.log("â†‘ä¸Šã‚¹ãƒ¯ã‚¤ãƒ—ï¼šå‰ã®ã‚¢ã‚¤ãƒ†ãƒ ");
      selectedInventoryIndex--;
    }

    // ãƒ«ãƒ¼ãƒ—å‡¦ç†
    const len = player.inventory.length;
    if (len > 0) {
      selectedInventoryIndex = (selectedInventoryIndex + len) % len;
    } else {
      selectedInventoryIndex = 0;
    }
  }

  inventoryTouchStartY = null;
  isInventorySwipeAllowed = false;
}, { passive: true });
  
  
  //let inventoryTouchStartY = null;

  
  canvas.addEventListener("touchend", (e) => {
    if (inventoryTouchStartY === null) return;
    const endY = e.changedTouches[0].clientY;
    const diffY = endY - inventoryTouchStartY;
  
    if (Math.abs(diffY) > 50) {
      if (diffY > 0) {
        // â†“ä¸‹ã‚¹ãƒ¯ã‚¤ãƒ—ï¼šæ¬¡ã®ã‚¢ã‚¤ãƒ†ãƒ 
        selectedInventoryIndex++;
      } else {
        console.log("â†‘ä¸Šã‚¹ãƒ¯ã‚¤ãƒ—ï¼šå‰ã®ã‚¢ã‚¤ãƒ†ãƒ ");
        selectedInventoryIndex--;
      }
  
      // ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹
      const len = player.inventory.length;
      if (len > 0) {
        selectedInventoryIndex = (selectedInventoryIndex + len) % len;
      } else {
        selectedInventoryIndex = 0;
      }
    }
  
    inventoryTouchStartY = null;
  }, { passive: true });
  

  

  

  
  canvas.addEventListener("touchend", () => {
    stopCharge(); // ã‚¿ãƒƒãƒé›¢ã—ãŸã‚‰ä¸­æ–­
  }, { passive: true });
  
  




canvas.addEventListener("touchend", (e) => {
  if (draggingItem) {
    const dropX = canvas.width - 70;
    const dropY = canvas.height / 2 - 25;
    const dist = Math.hypot(dragX - dropX, dragY - dropY);

    if (dist < 50) {
      console.log("âœ… ä½¿ç”¨ã‚¹ãƒ­ãƒƒãƒˆã«ãƒ‰ãƒ­ãƒƒãƒ—ã•ã‚Œã¾ã—ãŸï¼");
      // TODO: ã“ã“ã§ã‚¢ã‚¤ãƒ†ãƒ ä½¿ç”¨å‡¦ç†ã‚’å…¥ã‚Œã‚‹
    }

    draggingItem = false;
  }
}, { passive: true });

  

canvas.addEventListener("touchend", () => {
  isDraggingItem = false;
  stopCharge();
});*/

  
  gameLoop();
  </script>
  
  </body>
  </html>
