<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>2025å¹´6æœˆ3æ—¥ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯FPS</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  function generateRandomMap(width, height) {
  const newMap = [];
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
        row.push(1); // å¤–å‘¨ã¯å£
      } else {
        row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
      }
    }
    newMap.push(row);
  }
  return newMap;
}

function findRandomEmptyTile(map) {
  while (true) {
    const x = Math.floor(Math.random() * map[0].length);
    const y = Math.floor(Math.random() * map.length);
    if (map[y][x] === 0) {
      return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
    }
  }
}

// ğŸ”½ ã“ã“ã§ãƒãƒƒãƒ—ã¨ã‚´ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
let map = generateRandomMap(8, 8);
let goal = findRandomEmptyTile(map);
/*
  const map = [
    [1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,1],
    [1,0,1,0,1,0,0,1],
    [0,0,0,0,0,0,1,1],
    [1,0,0,0,1,0,0,1],
    [1,0,1,0,0,0,0,1],
    [1,0,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1],
  ];
*/
  
  const bullets = [];

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
  

const playerStart = findRandomEmptyTile(map);
let posX = playerStart.x;
let posY = playerStart.y;
let angle = 0;

  //let posX = 3.5, posY = 3.5; angle = 0;// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
  let dir = 0; // è¦–ç‚¹ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  
  const items = [
    { x: 2.5, y: 2.5 }, // ãƒãƒƒãƒ—ä¸Šã®ä½ç½®ï¼ˆX, Yï¼‰
    { x: 5.2, y: 3.7 }
  ];

/*
  const goal = { x: 5.5, y: 3.5 }; //ã‚´ãƒ¼ãƒ«
*/

  const fov = Math.PI / 3; // 60åº¦è¦–é‡è§’
  const numRays = canvas.width;
  const maxDepth = 10;
  
  let enemyX = 5.5;
  let enemyY = 3.5;
  
  let enemyColor = "red";
  let enemyHitTimer = 0;
  let enemyHP = 3;
  
  //tama
  
  function shoot() {
  const bulletSpeed = 0.2;
  bullets.push({
    x: posX,
    y: posY,
    dx: Math.cos(dir) * bulletSpeed,
    dy: Math.sin(dir) * bulletSpeed,
    life: 50  // å¯¿å‘½ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
  });
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.dx;
    b.y += b.dy;
    b.life--;
    
        // å¼¾ã¨æ•µã®è·é›¢ã‚’è¨ˆç®—ã—ã¦å½“ãŸã‚Šåˆ¤å®š
    const dx = b.x - enemyX;
    const dy = b.y - enemyY;
    const distToEnemy = Math.sqrt(dx * dx + dy * dy);
    if (distToEnemy < 0.3) { // â† å‘½ä¸­åˆ¤å®šï¼ˆ0.3ãƒã‚¹ä»¥å†…ï¼‰
      bullets.splice(i, 1); // å¼¾ã‚’æ¶ˆã™
      enemyHP--;
      enemyColor = "orange"; // æ•µã®è‰²ã‚’å¤‰ãˆã‚‹
      enemyHitTimer = 30; // è‰²å¤‰åŒ–æŒç¶šæ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
      
      if(enemyHP <= 0){
        enemyHP = 0;
        enemyX = -1000;
        enemyY = -1000;
      }
      continue;
    }

    // å£ã«å½“ãŸã‚‹ or å¯¿å‘½çµ‚äº†ã§å‰Šé™¤
    const mapX = Math.floor(b.x);
    const mapY = Math.floor(b.y);
    if (b.life <= 0 || map[mapY][mapX] !== 0) {
      bullets.splice(i, 1);
    }
  }
}

//æ•µ
  function updateEnemy() {
    
    if(enemyHP > 0){
      const dx = posX - enemyX;
      const dy = posY - enemyY;
      const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.05) {
          enemyX += (dx / dist) * 0.01; // ã»ã‚“ã®å°‘ã—ã ã‘è¿‘ã¥ã
          enemyY += (dy / dist) * 0.01;
      }
    }
    
    if(enemyHitTimer > 0){
      enemyHitTimer--;
      if(enemyHitTimer === 0){
          enemyColor = "red";
        }
    }
  }
  
  function drawEnemy() {
  const dx = enemyX - posX;
  const dy = enemyY - posY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angleToEnemy = Math.atan2(dy, dx) - dir;
  const halfFov = fov / 2;
  
    if (Math.abs(angleToEnemy) < halfFov) {
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(2000, 500 / distance); // è¿‘ã„ã¨å¤§ããã€é ã„ã¨å°ã•ã
  
      ctx.fillStyle = enemyColor;
      ctx.beginPath();
      ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  function drawItems() {
    const halfFov = fov / 2;

  items.forEach(item => {
    const dx = item.x - posX;
    const dy = item.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - dir;

      if (Math.abs(angleToItem) < halfFov) {
        const screenX = (angleToItem + halfFov) / fov * canvas.width;
        const size = Math.max(5, 200 / distance); // é ãã¯å°ã•ãã€è¿‘ãã¯å¤§ãã
  
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2 + 50, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
  
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const halfFov = fov / 2;
    
    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
      const maxSize = 20;
      const size = Math.max(4, maxSize / dist);
  
      ctx.beginPath();
      ctx.fillStyle = "lime"; // ã‚´ãƒ¼ãƒ«è‰²
      ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  let goalReached = false;
  
  function checkGoalReached() {
    if(goalReached)return;
    
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 0.5) {
      goalReached = true;
      alert("CLEAR");
      // ã¾ãŸã¯æ¬¡ã®éšå±¤ã¸ç§»è¡Œå‡¦ç†ãªã©
    }
  }
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (dir - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // è·é›¢ã«å¿œã˜ã¦å£ã®é«˜ã•ã‚’èª¿æ•´ï¼ˆé ã„ã»ã©å°ã•ãï¼‰
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }

  function render() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    castRays();
    drawEnemy();
    drawBullets();
    drawItems();
    drawGoal();
  }

  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(dir) * moveSpeed;
    const nextY = posY + Math.sin(dir) * moveSpeed;
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function rotate(angle) {
    dir += angle;
  }
  
  document.addEventListener("keydown", (e) => {
  switch(e.key) {
    case "ArrowLeft": rotate(-0.05); break;
    case "ArrowRight": rotate(0.05); break;
    case "ArrowUp": move(true); break;
    case "ArrowDown": move(false); break;
    case " ": shoot(); break; // â† ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å¼¾ç™ºå°„ï¼
  }
});
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // â†å·¦å›è»¢ãƒ•ãƒ©ã‚°
    let isTurningRight = false;  // â†å³å›è»¢ãƒ•ãƒ©ã‚°
    let touchStartY = null;
    let touchStartX = null;
    
    // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒé–‹å§‹æ™‚ã«Yä½ç½®ã‚’è¨˜éŒ²
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: true });
  
  // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒç§»å‹•ä¸­ã«ä¸€å®šè·é›¢ä¸Šã«å‹•ã„ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°ON
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null) return;
  
    const touchY = e.touches[0].clientY;
    const dy = touchStartY - touchY;
  
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    }else if(dy < -50){
      isMovingForward = false;
      isMovingBackward = true;
    }
  }, { passive: true });
  
  // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒãŒçµ‚ã‚ã£ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°OFFï¼†ãƒªã‚»ãƒƒãƒˆ
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isMovingBackward = false;
    touchStartY = null;
  }, { passive: true });
  

canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;  // â†æ—¢å­˜ã®Yè¨˜éŒ²ï¼ˆå‰é€²ç”¨ï¼‰
    touchStartX = e.touches[0].clientX;  // â†ğŸ†• å·¦å³å›è»¢ç”¨
  }
}, { passive: true });

canvas.addEventListener("touchmove", (e) => {
  if (touchStartY === null || touchStartX === null) return;

  const touchY = e.touches[0].clientY;
  const touchX = e.touches[0].clientX;

  const dy = touchStartY - touchY;
  const dx = touchX - touchStartX;

  // å‰é€²
  if (dy > 50) {
    isMovingForward = true;
  }
  
  if (dx > 50) {
    isTurningRight = true;      // å³ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
    isTurningLeft = false;
  } else if (dx < -50) {
    isTurningLeft = true;       // å·¦ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
    isTurningRight = false;
  }

  // å·¦å³å›è»¢ï¼ˆä¸€å®šè·é›¢å‹•ã‹ã—ãŸã‚‰å›è»¢ï¼‰
  if (dx > 50) {
    rotate(0.2);   // â†’å³ã¸å›è»¢ï¼ˆå³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
    touchStartX = touchX; // â†å›è»¢ã®é€£ç¶šåˆ¤å®šç”¨ã«æ›´æ–°
  } else if (dx < -50) {
    rotate(-0.2);  // â†å·¦ã¸å›è»¢ï¼ˆå·¦ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
    touchStartX = touchX; // â†ã“ã¡ã‚‰ã‚‚æ›´æ–°
  }
}, { passive: true });

canvas.addEventListener("touchend", (e) => {
  isMovingForward = false;
  isTurningLeft = false;
  isTurningRight = false;
  touchStartY = null;
  touchStartX = null;  // ğŸ”§è¿½åŠ ï¼šXæ–¹å‘ã®è¨˜éŒ²ã‚‚ãƒªã‚»ãƒƒãƒˆ
}, { passive: true });
 

  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });

  render();
  

  function gameLoop() {
    
    
    if(isMovingForward){
      move(true);
    }
    
    if(isMovingBackward){
      move(false);
    }
    updateEnemy();
    updateBullets();
    if (isTurningLeft) {
    rotate(-0.05); // â† æ»‘ã‚‰ã‹å·¦å›è»¢
    }
    if (isTurningRight) {
      rotate(0.05);  // â†’ æ»‘ã‚‰ã‹å³å›è»¢
    }
    
    checkGoalReached();
    render();
    requestAnimationFrame(gameLoop);
    //console.log("Enemy position:", enemyX.toFixed(2), enemyY.toFixed(2));
  
  }


gameLoop(); // â† ã“ã‚Œã‚’ script ã®æœ€å¾Œã«æ›¸ãï¼
</script>

</body>
</html>
