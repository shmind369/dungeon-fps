  <!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>6æœˆ4æ—¥ãƒ­ãƒ¼ã‚°ãƒ©ã‚¤ã‚¯FPS</title>
    <style>
      body {
        margin: 0;
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
  <canvas id="gameCanvas"></canvas>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  function generateRandomMap(width, height) {
  const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // å¤–å‘¨ã¯å£
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
        }
      }
      newMap.push(row);
    }
    return newMap;
  }
  
  function generateRandomMap(width, height) {
    const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // å¤–å‘¨ã¯å£
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%ã§å£
        }
      }
      newMap.push(row);
    }
    return newMap;
  }

  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
      }
    }
  }
  
  //
  function carvePath(map, start, goal) {
    let x = Math.floor(start.x);
    let y = Math.floor(start.y);
    const gx = Math.floor(goal.x);
    const gy = Math.floor(goal.y);
  
    while (x !== gx || y !== gy) {
      map[y][x] = 0; // é“ã‚’æ˜ã‚‹
  
      if (Math.random() < 0.5 && x !== gx) {
        x += gx > x ? 1 : -1;
      } else if (y !== gy) {
        y += gy > y ? 1 : -1;
      }
    }
  }
  
  //const start = { x: 1, y: 1 };
  //const goal = findRandomEmptyTile(map);
  //carvePath(map, start, goal);

  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // ä¸­å¿ƒã«ç½®ã
      }
    }
  }
  
  // ğŸ”½ ã“ã“ã§ãƒãƒƒãƒ—ã¨ã‚´ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
  let map = generateRandomMap(8, 8);
  let goal = findRandomEmptyTile(map);
  
  let explored = [];
    for (let y = 0; y < map.length; y++) {
      explored[y] = [];
    for (let x = 0; x < map[0].length; x++) {
      explored[y][x] = false; // ã¾ã æ¢ç´¢ã—ã¦ã„ãªã„
    }
  }
  
  const start = {x:1.5,y:1.5};
  
  carvePath(map,start,goal);
  let posX = start.x;
  let posY = start.y;
  
  
  const bullets = [];

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
 
  let angle = 0;

  //let posX = 3.5, posY = 3.5; angle = 0;// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®
  let dir = 0; // è¦–ç‚¹ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰
  
  const items = [
    { x: 2.5, y: 2.5 }, // ãƒãƒƒãƒ—ä¸Šã®ä½ç½®ï¼ˆX, Yï¼‰
    { x: 5.2, y: 3.7 }
  ];

/*
  const goal = { x: 5.5, y: 3.5 }; //ã‚´ãƒ¼ãƒ«
*/

  const fov = Math.PI / 3; // 60åº¦è¦–é‡è§’
  const numRays = canvas.width;
  const maxDepth = 10;
  
  let enemyX = 5.5;
  let enemyY = 3.5;
  
  let enemyColor = "red";
  let enemyHitTimer = 0;
  let enemyHP = 3;
  
  function drawMiniMap() {
  const scale = 10;
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  // ğŸ”§ èƒŒæ™¯ã‚’ç™½ã«å¡—ã‚‹ï¼ˆå·¦ä¸Šã«æç”»ï¼‰
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue;

      ctx.fillStyle = (map[y][x] === 1) ? "gray" : "black";
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ï¼ˆé’ï¼‰
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);
  
 
}
  
  
 /*function drawMiniMap() {
  const scale = 10; // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®æ‹¡å¤§ç‡ï¼ˆä¾‹: 1ãƒã‚¹10pxï¼‰
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  // ğŸ”§ èƒŒæ™¯ã‚’ç™½ã§å¡—ã‚‹
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  // ãƒãƒƒãƒ—æç”»
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue; // æœªæ¢ç´¢ãªã‚‰æç”»ã—ãªã„

      if (map[y][x] === 1) {
        ctx.fillStyle = "gray"; // å£
      } else {
        ctx.fillStyle = "black"; // é€šè·¯
      }
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // ğŸ”µ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®è¡¨ç¤º
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);


  // ã‚´ãƒ¼ãƒ«è¡¨ç¤ºï¼ˆè¦‹ãˆã‚‹ä½ç½®ã«ã‚ã‚‹ãªã‚‰ï¼‰
  const gx = Math.floor(goal.x);
  const gy = Math.floor(goal.y);
  if (explored[gy][gx]) {
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(offsetX + goal.x * scale, offsetY + goal.y * scale, scale / 3, 0, Math.PI * 2);
    ctx.fill();
  }
}*/
  
  //tama
  
  function shoot() {
  const bulletSpeed = 0.2;
    bullets.push({
      x: posX,
      y: posY,
      dx: Math.cos(dir) * bulletSpeed,
      dy: Math.sin(dir) * bulletSpeed,
      life: 50  // å¯¿å‘½ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
    });
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.dx;
      b.y += b.dy;
      b.life--;
      
          // å¼¾ã¨æ•µã®è·é›¢ã‚’è¨ˆç®—ã—ã¦å½“ãŸã‚Šåˆ¤å®š
      const dx = b.x - enemyX;
      const dy = b.y - enemyY;
      const distToEnemy = Math.sqrt(dx * dx + dy * dy);
      if (distToEnemy < 0.3) { // â† å‘½ä¸­åˆ¤å®šï¼ˆ0.3ãƒã‚¹ä»¥å†…ï¼‰
        bullets.splice(i, 1); // å¼¾ã‚’æ¶ˆã™
        enemyHP--;
        enemyColor = "orange"; // æ•µã®è‰²ã‚’å¤‰ãˆã‚‹
        enemyHitTimer = 30; // è‰²å¤‰åŒ–æŒç¶šæ™‚é–“ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ æ•°ï¼‰
        
        if(enemyHP <= 0){
          enemyHP = 0;
          enemyX = -1000;
          enemyY = -1000;
        }
        continue;
      }
  
      // å£ã«å½“ãŸã‚‹ or å¯¿å‘½çµ‚äº†ã§å‰Šé™¤
      const mapX = Math.floor(b.x);
      const mapY = Math.floor(b.y);
        if (b.life <= 0 || map[mapY][mapX] !== 0) {
          bullets.splice(i, 1);
        }
    }
  }

//æ•µ
  function updateEnemy() {
    
    if(enemyHP > 0){
      const dx = posX - enemyX;
      const dy = posY - enemyY;
      const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.05) {
          enemyX += (dx / dist) * 0.01; // ã»ã‚“ã®å°‘ã—ã ã‘è¿‘ã¥ã
          enemyY += (dy / dist) * 0.01;
      }
    }
    
    if(enemyHitTimer > 0){
      enemyHitTimer--;
      if(enemyHitTimer === 0){
          enemyColor = "red";
        }
    }
  }
  
  function drawEnemy() {
  const dx = enemyX - posX;
  const dy = enemyY - posY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angleToEnemy = Math.atan2(dy, dx) - dir;
  const halfFov = fov / 2;
  
    if (Math.abs(angleToEnemy) < halfFov) {
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(2000, 500 / distance); // è¿‘ã„ã¨å¤§ããã€é ã„ã¨å°ã•ã
  
      ctx.fillStyle = enemyColor;
      ctx.beginPath();
      ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  function drawItems() {
    const halfFov = fov / 2;

  items.forEach(item => {
    const dx = item.x - posX;
    const dy = item.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - dir;

      if (Math.abs(angleToItem) < halfFov) {
        const screenX = (angleToItem + halfFov) / fov * canvas.width;
        const size = Math.max(5, 200 / distance); // é ãã¯å°ã•ãã€è¿‘ãã¯å¤§ãã
  
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2 + 50, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
  
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawGoal() {
  const dx = goal.x - posX;
  const dy = goal.y - posY;
  const angleToGoal = Math.atan2(dy, dx) - dir;
  const dist = Math.sqrt(dx * dx + dy * dy);

  const halfFov = fov / 2;

    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
  
      //ï¼šãã®æ–¹å‘ã®å£ã¨ã®è·é›¢ã‚’å–å¾—
      let rayAngle = normalizeAngle(dir + angleToGoal);
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);
      let rayDist = 0;
      let hit = false;
      while (!hit && rayDist < maxDepth) {
        rayDist += 0.01;
        let testX = Math.floor(posX + eyeX * rayDist);
        let testY = Math.floor(posY + eyeY * rayDist);
        if (
          testX < 0 || testY < 0 ||
          testX >= mapWidth || testY >= mapHeight
        ) {
          hit = true;
          rayDist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
  
      // ã‚´ãƒ¼ãƒ«ãŒæ‰‹å‰ã«ã‚ã‚‹ã¨ãã ã‘æç”»
      if (dist < rayDist) {
        const maxSize = 80;
        const size = Math.max(4, maxSize / dist);
        ctx.beginPath();
        ctx.fillStyle = "lime";
        ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  
  function checkGoalReached() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 0.5) {
      // ã‚´ãƒ¼ãƒ«ã«åˆ°é”ã—ãŸã‚‰æ¬¡ã®ã‚¨ãƒªã‚¢ã¸ï¼
  
      // ğŸ¯ æ–°ã—ã„ãƒãƒƒãƒ—ã‚’ç”Ÿæˆ
      map = generateRandomMap(mapWidth, mapHeight);
  
      // ğŸ¯ æ–°ã—ã„ã‚´ãƒ¼ãƒ«ã‚’è¨­ç½®
      goal = findRandomEmptyTile(map);
  
      // ğŸ¯ æ–°ã—ã„ã‚¹ã‚¿ãƒ¼ãƒˆä½ç½®
      const playerStart = findRandomEmptyTile(map);
      carvePath(map, playerStart, goal);  // é€šè·¯ã‚’æ˜ã‚‹
      posX = playerStart.x;
      posY = playerStart.y;
  
      // ğŸ¯ æ¢ç´¢çŠ¶æ…‹ã‚‚ãƒªã‚»ãƒƒãƒˆ
      explored = [];
      for (let y = 0; y < map.length; y++) {
        explored[y] = [];
        for (let x = 0; x < map[0].length; x++) {
          explored[y][x] = false;
        }
      }
  
      // ğŸ‰ åŠ¹æœéŸ³ã‚„æ¼”å‡ºã‚‚ã“ã“ã«è¿½åŠ ã§ãã‚‹
      console.log("ğŸšª æ¬¡ã®ã‚¨ãƒªã‚¢ã«é·ç§»ã—ã¾ã—ãŸï¼");
    }
  }
  
  /*
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = normalizeAngle(Math.atan2(dy, dx) - dir);
    //const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const halfFov = fov / 2;
    
    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
      const maxSize = 180;
      const size = Math.max(4, maxSize / dist);
  
      ctx.beginPath();
      ctx.fillStyle = "lime"; // ã‚´ãƒ¼ãƒ«è‰²
      ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }*/
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  }
  
  let goalReached = false;
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (dir - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // è·é›¢ã«å¿œã˜ã¦å£ã®é«˜ã•ã‚’èª¿æ•´ï¼ˆé ã„ã»ã©å°ã•ãï¼‰
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }

  function render() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    castRays();
    drawEnemy();
    drawBullets();
    drawItems();
    drawGoal();
    //checkGoalReached();
    
    drawMiniMap();
  }

  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(dir) * moveSpeed;
    const nextY = posY + Math.sin(dir) * moveSpeed;
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function rotate(angle) {
    dir += angle;
  }
  
  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft": rotate(-0.05); break;
      case "ArrowRight": rotate(0.05); break;
      case "ArrowUp": move(true); break;
      case "ArrowDown": move(false); break;
      case " ": shoot(); break; // â† ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§å¼¾ç™ºå°„ï¼
    }
  });
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // â†å·¦å›è»¢ãƒ•ãƒ©ã‚°
    let isTurningRight = false;  // â†å³å›è»¢ãƒ•ãƒ©ã‚°
    let touchStartY = null;
    let touchStartX = null;
    
    // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒé–‹å§‹æ™‚ã«Yä½ç½®ã‚’è¨˜éŒ²
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: true });
  
  // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒç§»å‹•ä¸­ã«ä¸€å®šè·é›¢ä¸Šã«å‹•ã„ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°ON
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null) return;
  
    const touchY = e.touches[0].clientY;
    const dy = touchStartY - touchY;
  
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    }else if(dy < -50){
      isMovingForward = false;
      isMovingBackward = true;
    }
  }, { passive: true });
  
  // ğŸ”§è¿½åŠ ï¼šã‚¿ãƒƒãƒãŒçµ‚ã‚ã£ãŸã‚‰å‰é€²ãƒ•ãƒ©ã‚°OFFï¼†ãƒªã‚»ãƒƒãƒˆ
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isMovingBackward = false;
    touchStartY = null;
  }, { passive: true });
  

  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;  // â†æ—¢å­˜ã®Yè¨˜éŒ²ï¼ˆå‰é€²ç”¨ï¼‰
      touchStartX = e.touches[0].clientX;  // â†ğŸ†• å·¦å³å›è»¢ç”¨
    }
  }, { passive: true });
  
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null || touchStartX === null) return;
  
    const touchY = e.touches[0].clientY;
    const touchX = e.touches[0].clientX;
  
    const dy = touchStartY - touchY;
    const dx = touchX - touchStartX;
  
    // å‰é€²
    if (dy > 50) {
      isMovingForward = true;
    }
    
    if (dx > 50) {
      isTurningRight = true;      // å³ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
      isTurningLeft = false;
    } else if (dx < -50) {
      isTurningLeft = true;       // å·¦ã‚¹ãƒ¯ã‚¤ãƒ— â†’ å›è»¢ãƒ•ãƒ©ã‚°ON
      isTurningRight = false;
    }
  
    // å·¦å³å›è»¢ï¼ˆä¸€å®šè·é›¢å‹•ã‹ã—ãŸã‚‰å›è»¢ï¼‰
    if (dx > 50) {
      rotate(0.2);   // â†’å³ã¸å›è»¢ï¼ˆå³ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
      touchStartX = touchX; // â†å›è»¢ã®é€£ç¶šåˆ¤å®šç”¨ã«æ›´æ–°
    } else if (dx < -50) {
      rotate(-0.2);  // â†å·¦ã¸å›è»¢ï¼ˆå·¦ã‚¹ãƒ¯ã‚¤ãƒ—ï¼‰
      touchStartX = touchX; // â†ã“ã¡ã‚‰ã‚‚æ›´æ–°
    }
  }, { passive: true });

  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isTurningLeft = false;
    isTurningRight = false;
    touchStartY = null;
    touchStartX = null;  // ğŸ”§è¿½åŠ ï¼šXæ–¹å‘ã®è¨˜éŒ²ã‚‚ãƒªã‚»ãƒƒãƒˆ
  }, { passive: true });
 

  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });

  render();
  

  function gameLoop() {
    
    
    if(isMovingForward){
      move(true);
    }
    
    if(isMovingBackward){
      move(false);
    }
    updateEnemy();
    updateBullets();
    if (isTurningLeft) {
    rotate(-0.05); // â† æ»‘ã‚‰ã‹å·¦å›è»¢
    }
    if (isTurningRight) {
      rotate(0.05);  // â†’ æ»‘ã‚‰ã‹å³å›è»¢
    }
    
    checkGoalReached();
    render();
    requestAnimationFrame(gameLoop);
    
    explored[Math.floor(posY)][Math.floor(posX)] = true;
    //console.log("Enemy position:", enemyX.toFixed(2), enemyY.toFixed(2));
  
  }


  gameLoop(); // â† ã“ã‚Œã‚’ script ã®æœ€å¾Œã«æ›¸ãï¼
  </script>
  
  </body>
  </html>
