  <!DOCTYPE html>
  <html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>6月4日ローグライクFPS</title>
    <style>
      body {
        margin: 0;
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
  <canvas id="gameCanvas"></canvas>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  function generateRandomMap(width, height) {
  const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // 外周は壁
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%で壁
        }
      }
      newMap.push(row);
    }
    return newMap;
  }
  
  function generateRandomMap(width, height) {
    const newMap = [];
    for (let y = 0; y < height; y++) {
      const row = [];
      for (let x = 0; x < width; x++) {
        if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
          row.push(1); // 外周は壁
        } else {
          row.push(Math.random() < 0.2 ? 1 : 0); // 20%で壁
        }
      }
      newMap.push(row);
    }
    return newMap;
  }

  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // 中心に置く
      }
    }
  }
  
  //
  function carvePath(map, start, goal) {
    let x = Math.floor(start.x);
    let y = Math.floor(start.y);
    const gx = Math.floor(goal.x);
    const gy = Math.floor(goal.y);
  
    while (x !== gx || y !== gy) {
      map[y][x] = 0; // 道を掘る
  
      if (Math.random() < 0.5 && x !== gx) {
        x += gx > x ? 1 : -1;
      } else if (y !== gy) {
        y += gy > y ? 1 : -1;
      }
    }
  }
  
  //const start = { x: 1, y: 1 };
  //const goal = findRandomEmptyTile(map);
  //carvePath(map, start, goal);

  function findRandomEmptyTile(map) {
    while (true) {
      const x = Math.floor(Math.random() * map[0].length);
      const y = Math.floor(Math.random() * map.length);
      if (map[y][x] === 0) {
        return { x: x + 0.5, y: y + 0.5 }; // 中心に置く
      }
    }
  }
  
  // 🔽 ここでマップとゴールを初期化
  let map = generateRandomMap(8, 8);
  let goal = findRandomEmptyTile(map);
  
  let explored = [];
    for (let y = 0; y < map.length; y++) {
      explored[y] = [];
    for (let x = 0; x < map[0].length; x++) {
      explored[y][x] = false; // まだ探索していない
    }
  }
  
  const start = {x:1.5,y:1.5};
  
  carvePath(map,start,goal);
  let posX = start.x;
  let posY = start.y;
  
  
  const bullets = [];

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
 
  let angle = 0;

  //let posX = 3.5, posY = 3.5; angle = 0;// プレイヤーの位置
  let dir = 0; // 視点の角度（ラジアン）
  
  const items = [
    { x: 2.5, y: 2.5 }, // マップ上の位置（X, Y）
    { x: 5.2, y: 3.7 }
  ];

/*
  const goal = { x: 5.5, y: 3.5 }; //ゴール
*/

  const fov = Math.PI / 3; // 60度視野角
  const numRays = canvas.width;
  const maxDepth = 10;
  
  let enemyX = 5.5;
  let enemyY = 3.5;
  
  let enemyColor = "red";
  let enemyHitTimer = 0;
  let enemyHP = 3;
  
  function drawMiniMap() {
  const scale = 10;
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  // 🔧 背景を白に塗る（左上に描画）
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue;

      ctx.fillStyle = (map[y][x] === 1) ? "gray" : "black";
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // プレイヤーの位置（青）
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);
  
 
}
  
  
 /*function drawMiniMap() {
  const scale = 10; // ミニマップの拡大率（例: 1マス10px）
  const mapWidthPx = map[0].length * scale;
  const mapHeightPx = map.length * scale;

  // 🔧 背景を白で塗る
  ctx.fillStyle = "white";
  ctx.fillRect(0, 0, mapWidthPx, mapHeightPx);

  // マップ描画
  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[0].length; x++) {
      if (!explored[y][x]) continue; // 未探索なら描画しない

      if (map[y][x] === 1) {
        ctx.fillStyle = "gray"; // 壁
      } else {
        ctx.fillStyle = "black"; // 通路
      }
      ctx.fillRect(x * scale, y * scale, scale, scale);
    }
  }

  // 🔵 プレイヤー位置表示
  ctx.fillStyle = "blue";
  ctx.fillRect(Math.floor(posX * scale), Math.floor(posY * scale), scale, scale);


  // ゴール表示（見える位置にあるなら）
  const gx = Math.floor(goal.x);
  const gy = Math.floor(goal.y);
  if (explored[gy][gx]) {
    ctx.fillStyle = "lime";
    ctx.beginPath();
    ctx.arc(offsetX + goal.x * scale, offsetY + goal.y * scale, scale / 3, 0, Math.PI * 2);
    ctx.fill();
  }
}*/
  
  //tama
  
  function shoot() {
  const bulletSpeed = 0.2;
    bullets.push({
      x: posX,
      y: posY,
      dx: Math.cos(dir) * bulletSpeed,
      dy: Math.sin(dir) * bulletSpeed,
      life: 50  // 寿命（フレーム数）
    });
  }

  function updateBullets() {
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.dx;
      b.y += b.dy;
      b.life--;
      
          // 弾と敵の距離を計算して当たり判定
      const dx = b.x - enemyX;
      const dy = b.y - enemyY;
      const distToEnemy = Math.sqrt(dx * dx + dy * dy);
      if (distToEnemy < 0.3) { // ← 命中判定（0.3マス以内）
        bullets.splice(i, 1); // 弾を消す
        enemyHP--;
        enemyColor = "orange"; // 敵の色を変える
        enemyHitTimer = 30; // 色変化持続時間（フレーム数）
        
        if(enemyHP <= 0){
          enemyHP = 0;
          enemyX = -1000;
          enemyY = -1000;
        }
        continue;
      }
  
      // 壁に当たる or 寿命終了で削除
      const mapX = Math.floor(b.x);
      const mapY = Math.floor(b.y);
        if (b.life <= 0 || map[mapY][mapX] !== 0) {
          bullets.splice(i, 1);
        }
    }
  }

//敵
  function updateEnemy() {
    
    if(enemyHP > 0){
      const dx = posX - enemyX;
      const dy = posY - enemyY;
      const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.05) {
          enemyX += (dx / dist) * 0.01; // ほんの少しだけ近づく
          enemyY += (dy / dist) * 0.01;
      }
    }
    
    if(enemyHitTimer > 0){
      enemyHitTimer--;
      if(enemyHitTimer === 0){
          enemyColor = "red";
        }
    }
  }
  
  function drawEnemy() {
  const dx = enemyX - posX;
  const dy = enemyY - posY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angleToEnemy = Math.atan2(dy, dx) - dir;
  const halfFov = fov / 2;
  
    if (Math.abs(angleToEnemy) < halfFov) {
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(2000, 500 / distance); // 近いと大きく、遠いと小さく
  
      ctx.fillStyle = enemyColor;
      ctx.beginPath();
      ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  function drawItems() {
    const halfFov = fov / 2;

  items.forEach(item => {
    const dx = item.x - posX;
    const dy = item.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - dir;

      if (Math.abs(angleToItem) < halfFov) {
        const screenX = (angleToItem + halfFov) / fov * canvas.width;
        const size = Math.max(5, 200 / distance); // 遠くは小さく、近くは大きく
  
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2 + 50, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
  
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawGoal() {
  const dx = goal.x - posX;
  const dy = goal.y - posY;
  const angleToGoal = Math.atan2(dy, dx) - dir;
  const dist = Math.sqrt(dx * dx + dy * dy);

  const halfFov = fov / 2;

    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
  
      //：その方向の壁との距離を取得
      let rayAngle = normalizeAngle(dir + angleToGoal);
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);
      let rayDist = 0;
      let hit = false;
      while (!hit && rayDist < maxDepth) {
        rayDist += 0.01;
        let testX = Math.floor(posX + eyeX * rayDist);
        let testY = Math.floor(posY + eyeY * rayDist);
        if (
          testX < 0 || testY < 0 ||
          testX >= mapWidth || testY >= mapHeight
        ) {
          hit = true;
          rayDist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }
  
      // ゴールが手前にあるときだけ描画
      if (dist < rayDist) {
        const maxSize = 80;
        const size = Math.max(4, maxSize / dist);
        ctx.beginPath();
        ctx.fillStyle = "lime";
        ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
  
  function checkGoalReached() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 0.5) {
      // ゴールに到達したら次のエリアへ！
  
      // 🎯 新しいマップを生成
      map = generateRandomMap(mapWidth, mapHeight);
  
      // 🎯 新しいゴールを設置
      goal = findRandomEmptyTile(map);
  
      // 🎯 新しいスタート位置
      const playerStart = findRandomEmptyTile(map);
      carvePath(map, playerStart, goal);  // 通路を掘る
      posX = playerStart.x;
      posY = playerStart.y;
  
      // 🎯 探索状態もリセット
      explored = [];
      for (let y = 0; y < map.length; y++) {
        explored[y] = [];
        for (let x = 0; x < map[0].length; x++) {
          explored[y][x] = false;
        }
      }
  
      // 🎉 効果音や演出もここに追加できる
      console.log("🚪 次のエリアに遷移しました！");
    }
  }
  
  /*
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = normalizeAngle(Math.atan2(dy, dx) - dir);
    //const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const halfFov = fov / 2;
    
    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
      const maxSize = 180;
      const size = Math.max(4, maxSize / dist);
  
      ctx.beginPath();
      ctx.fillStyle = "lime"; // ゴール色
      ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }*/
  
  function normalizeAngle(angle) {
    return Math.atan2(Math.sin(angle), Math.cos(angle));
  }
  
  let goalReached = false;
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (dir - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // 距離に応じて壁の高さを調整（遠いほど小さく）
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }

  function render() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    castRays();
    drawEnemy();
    drawBullets();
    drawItems();
    drawGoal();
    //checkGoalReached();
    
    drawMiniMap();
  }

  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(dir) * moveSpeed;
    const nextY = posY + Math.sin(dir) * moveSpeed;
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function rotate(angle) {
    dir += angle;
  }
  
  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft": rotate(-0.05); break;
      case "ArrowRight": rotate(0.05); break;
      case "ArrowUp": move(true); break;
      case "ArrowDown": move(false); break;
      case " ": shoot(); break; // ← スペースキーで弾発射！
    }
  });
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // ←左回転フラグ
    let isTurningRight = false;  // ←右回転フラグ
    let touchStartY = null;
    let touchStartX = null;
    
    // 🔧追加：タッチ開始時にY位置を記録
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: true });
  
  // 🔧追加：タッチ移動中に一定距離上に動いたら前進フラグON
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null) return;
  
    const touchY = e.touches[0].clientY;
    const dy = touchStartY - touchY;
  
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    }else if(dy < -50){
      isMovingForward = false;
      isMovingBackward = true;
    }
  }, { passive: true });
  
  // 🔧追加：タッチが終わったら前進フラグOFF＆リセット
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isMovingBackward = false;
    touchStartY = null;
  }, { passive: true });
  

  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;  // ←既存のY記録（前進用）
      touchStartX = e.touches[0].clientX;  // ←🆕 左右回転用
    }
  }, { passive: true });
  
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null || touchStartX === null) return;
  
    const touchY = e.touches[0].clientY;
    const touchX = e.touches[0].clientX;
  
    const dy = touchStartY - touchY;
    const dx = touchX - touchStartX;
  
    // 前進
    if (dy > 50) {
      isMovingForward = true;
    }
    
    if (dx > 50) {
      isTurningRight = true;      // 右スワイプ → 回転フラグON
      isTurningLeft = false;
    } else if (dx < -50) {
      isTurningLeft = true;       // 左スワイプ → 回転フラグON
      isTurningRight = false;
    }
  
    // 左右回転（一定距離動かしたら回転）
    if (dx > 50) {
      rotate(0.2);   // →右へ回転（右スワイプ）
      touchStartX = touchX; // ←回転の連続判定用に更新
    } else if (dx < -50) {
      rotate(-0.2);  // ←左へ回転（左スワイプ）
      touchStartX = touchX; // ←こちらも更新
    }
  }, { passive: true });

  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isTurningLeft = false;
    isTurningRight = false;
    touchStartY = null;
    touchStartX = null;  // 🔧追加：X方向の記録もリセット
  }, { passive: true });
 

  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });

  render();
  

  function gameLoop() {
    
    
    if(isMovingForward){
      move(true);
    }
    
    if(isMovingBackward){
      move(false);
    }
    updateEnemy();
    updateBullets();
    if (isTurningLeft) {
    rotate(-0.05); // ← 滑らか左回転
    }
    if (isTurningRight) {
      rotate(0.05);  // → 滑らか右回転
    }
    
    checkGoalReached();
    render();
    requestAnimationFrame(gameLoop);
    
    explored[Math.floor(posY)][Math.floor(posX)] = true;
    //console.log("Enemy position:", enemyX.toFixed(2), enemyY.toFixed(2));
  
  }


  gameLoop(); // ← これを script の最後に書く！
  </script>
  
  </body>
  </html>
