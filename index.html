<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>2025Âπ¥6Êúà3Êó•„É≠„Éº„Ç∞„É©„Ç§„ÇØFPS</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  
  function generateRandomMap(width, height) {
  const newMap = [];
  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      if (x === 0 || y === 0 || x === width - 1 || y === height - 1) {
        row.push(1); // Â§ñÂë®„ÅØÂ£Å
      } else {
        row.push(Math.random() < 0.2 ? 1 : 0); // 20%„ÅßÂ£Å
      }
    }
    newMap.push(row);
  }
  return newMap;
}

function findRandomEmptyTile(map) {
  while (true) {
    const x = Math.floor(Math.random() * map[0].length);
    const y = Math.floor(Math.random() * map.length);
    if (map[y][x] === 0) {
      return { x: x + 0.5, y: y + 0.5 }; // ‰∏≠ÂøÉ„Å´ÁΩÆ„Åè
    }
  }
}

// üîΩ „Åì„Åì„Åß„Éû„ÉÉ„Éó„Å®„Ç¥„Éº„É´„ÇíÂàùÊúüÂåñ
let map = generateRandomMap(8, 8);
let goal = findRandomEmptyTile(map);
/*
  const map = [
    [1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,1,1],
    [1,0,1,0,1,0,0,1],
    [0,0,0,0,0,0,1,1],
    [1,0,0,0,1,0,0,1],
    [1,0,1,0,0,0,0,1],
    [1,0,0,0,1,0,0,1],
    [1,1,1,1,1,1,1,1],
  ];
*/
  
  const bullets = [];

  const tileSize = 64;
  const mapWidth = map[0].length;
  const mapHeight = map.length;
  

const playerStart = findRandomEmptyTile(map);
let posX = playerStart.x;
let posY = playerStart.y;
let angle = 0;

  //let posX = 3.5, posY = 3.5; angle = 0;// „Éó„É¨„Ç§„É§„Éº„ÅÆ‰ΩçÁΩÆ
  let dir = 0; // Ë¶ñÁÇπ„ÅÆËßíÂ∫¶Ôºà„É©„Ç∏„Ç¢„É≥Ôºâ
  
  const items = [
    { x: 2.5, y: 2.5 }, // „Éû„ÉÉ„Éó‰∏ä„ÅÆ‰ΩçÁΩÆÔºàX, YÔºâ
    { x: 5.2, y: 3.7 }
  ];

/*
  const goal = { x: 5.5, y: 3.5 }; //„Ç¥„Éº„É´
*/

  const fov = Math.PI / 3; // 60Â∫¶Ë¶ñÈáéËßí
  const numRays = canvas.width;
  const maxDepth = 10;
  
  let enemyX = 5.5;
  let enemyY = 3.5;
  
  let enemyColor = "red";
  let enemyHitTimer = 0;
  let enemyHP = 3;
  
  //tama
  
  function shoot() {
  const bulletSpeed = 0.2;
  bullets.push({
    x: posX,
    y: posY,
    dx: Math.cos(dir) * bulletSpeed,
    dy: Math.sin(dir) * bulletSpeed,
    life: 50  // ÂØøÂëΩÔºà„Éï„É¨„Éº„É†Êï∞Ôºâ
  });
}

function updateBullets() {
  for (let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.x += b.dx;
    b.y += b.dy;
    b.life--;
    
        // Âºæ„Å®Êïµ„ÅÆË∑ùÈõ¢„ÇíË®àÁÆó„Åó„Å¶ÂΩì„Åü„ÇäÂà§ÂÆö
    const dx = b.x - enemyX;
    const dy = b.y - enemyY;
    const distToEnemy = Math.sqrt(dx * dx + dy * dy);
    if (distToEnemy < 0.3) { // ‚Üê ÂëΩ‰∏≠Âà§ÂÆöÔºà0.3„Éû„Çπ‰ª•ÂÜÖÔºâ
      bullets.splice(i, 1); // Âºæ„ÇíÊ∂à„Åô
      enemyHP--;
      enemyColor = "orange"; // Êïµ„ÅÆËâ≤„ÇíÂ§â„Åà„Çã
      enemyHitTimer = 30; // Ëâ≤Â§âÂåñÊåÅÁ∂öÊôÇÈñìÔºà„Éï„É¨„Éº„É†Êï∞Ôºâ
      
      if(enemyHP <= 0){
        enemyHP = 0;
        enemyX = -1000;
        enemyY = -1000;
      }
      continue;
    }

    // Â£Å„Å´ÂΩì„Åü„Çã or ÂØøÂëΩÁµÇ‰∫Ü„ÅßÂâäÈô§
    const mapX = Math.floor(b.x);
    const mapY = Math.floor(b.y);
    if (b.life <= 0 || map[mapY][mapX] !== 0) {
      bullets.splice(i, 1);
    }
  }
}

//Êïµ
  function updateEnemy() {
    
    if(enemyHP > 0){
      const dx = posX - enemyX;
      const dy = posY - enemyY;
      const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > 0.05) {
          enemyX += (dx / dist) * 0.01; // „Åª„Çì„ÅÆÂ∞ë„Åó„Å†„ÅëËøë„Å•„Åè
          enemyY += (dy / dist) * 0.01;
      }
    }
    
    if(enemyHitTimer > 0){
      enemyHitTimer--;
      if(enemyHitTimer === 0){
          enemyColor = "red";
        }
    }
  }
  
  function drawEnemy() {
  const dx = enemyX - posX;
  const dy = enemyY - posY;
  const distance = Math.sqrt(dx * dx + dy * dy);
  const angleToEnemy = Math.atan2(dy, dx) - dir;
  const halfFov = fov / 2;
  
    if (Math.abs(angleToEnemy) < halfFov) {
      const screenX = (angleToEnemy + halfFov) / fov * canvas.width;
      const size = Math.min(2000, 500 / distance); // Ëøë„ÅÑ„Å®Â§ß„Åç„Åè„ÄÅÈÅ†„ÅÑ„Å®Â∞è„Åï„Åè
  
      ctx.fillStyle = enemyColor;
      ctx.beginPath();
      ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  function drawItems() {
    const halfFov = fov / 2;

  items.forEach(item => {
    const dx = item.x - posX;
    const dy = item.y - posY;
    const distance = Math.sqrt(dx * dx + dy * dy);
    const angleToItem = Math.atan2(dy, dx) - dir;

      if (Math.abs(angleToItem) < halfFov) {
        const screenX = (angleToItem + halfFov) / fov * canvas.width;
        const size = Math.max(5, 200 / distance); // ÈÅ†„Åè„ÅØÂ∞è„Åï„Åè„ÄÅËøë„Åè„ÅØÂ§ß„Åç„Åè
  
        ctx.fillStyle = "gold";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2 + 50, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }

  function drawBullets() {
    bullets.forEach(b => {
      const dx = b.x - posX;
      const dy = b.y - posY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const angleToBullet = Math.atan2(dy, dx) - dir;
      const halfFov = fov / 2;
  
      if (Math.abs(angleToBullet) < halfFov) {
        const screenX = (angleToBullet + halfFov) / fov * canvas.width;
        
        const maxSize = 30;
        const size = Math.max(2,maxSize/dist);
       // const size = Math.min(30, 300 / dist);
  
        ctx.fillStyle = "yellow";
        ctx.beginPath();
        ctx.arc(screenX, canvas.height / 2, size / 2, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  }
  
  function drawGoal() {
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const angleToGoal = Math.atan2(dy, dx) - angle;
    const dist = Math.sqrt(dx * dx + dy * dy);

    const halfFov = fov / 2;
    
    if (Math.abs(angleToGoal) < halfFov) {
      const screenX = (angleToGoal + halfFov) / fov * canvas.width;
      const maxSize = 20;
      const size = Math.max(4, maxSize / dist);
  
      ctx.beginPath();
      ctx.fillStyle = "lime"; // „Ç¥„Éº„É´Ëâ≤
      ctx.arc(screenX, canvas.height / 2, size, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  let goalReached = false;
  
  function checkGoalReached() {
    if(goalReached)return;
    
    const dx = goal.x - posX;
    const dy = goal.y - posY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    
    if (dist < 0.5) {
      goalReached = true;
      alert("CLEAR");
      // „Åæ„Åü„ÅØÊ¨°„ÅÆÈöéÂ±§„Å∏ÁßªË°åÂá¶ÁêÜ„Å™„Å©
    }
  }
  

  function castRays() {
    for (let i = 0; i < numRays; i++) {
      const rayAngle = (dir - fov / 2) + (i / numRays) * fov;
      let dist = 0;
      let hit = false;
      let eyeX = Math.cos(rayAngle);
      let eyeY = Math.sin(rayAngle);

      while (!hit && dist < maxDepth) {
        dist += 0.01;
        let testX = Math.floor(posX + eyeX * dist);
        let testY = Math.floor(posY + eyeY * dist);

        if (testX < 0 || testY < 0 || testX >= mapWidth || testY >= mapHeight) {
          hit = true;
          dist = maxDepth;
        } else if (map[testY][testX] > 0) {
          hit = true;
        }
      }

      // Ë∑ùÈõ¢„Å´Âøú„Åò„Å¶Â£Å„ÅÆÈ´ò„Åï„ÇíË™øÊï¥ÔºàÈÅ†„ÅÑ„Åª„Å©Â∞è„Åï„ÅèÔºâ
      const wallHeight = Math.min(canvas.height, canvas.height / dist);
      const shade = 255 - Math.min(255, dist * 50);
      ctx.fillStyle = `rgb(${shade},${shade},${shade})`;
      ctx.fillRect(i, (canvas.height - wallHeight) / 2, 1, wallHeight);
    }
  }

  function render() {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    castRays();
    drawEnemy();
    drawBullets();
    drawItems();
    drawGoal();
  }

  function move(forward) {
    const moveSpeed = forward ? 0.04 : -0.02;
    const nextX = posX + Math.cos(dir) * moveSpeed;
    const nextY = posY + Math.sin(dir) * moveSpeed;
    if (map[Math.floor(nextY)][Math.floor(nextX)] === 0) {
      posX = nextX;
      posY = nextY;
    }
  }

  function rotate(angle) {
    dir += angle;
  }
  
  document.addEventListener("keydown", (e) => {
  switch(e.key) {
    case "ArrowLeft": rotate(-0.05); break;
    case "ArrowRight": rotate(0.05); break;
    case "ArrowUp": move(true); break;
    case "ArrowDown": move(false); break;
    case " ": shoot(); break; // ‚Üê „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÂºæÁô∫Â∞ÑÔºÅ
  }
});
    
    let isMovingForward = false;
    let isMovingBackward = false;
    let isTurningLeft = false;   // ‚ÜêÂ∑¶ÂõûËª¢„Éï„É©„Ç∞
    let isTurningRight = false;  // ‚ÜêÂè≥ÂõûËª¢„Éï„É©„Ç∞
    let touchStartY = null;
    let touchStartX = null;
    
    // üîßËøΩÂä†Ôºö„Çø„ÉÉ„ÉÅÈñãÂßãÊôÇ„Å´Y‰ΩçÁΩÆ„ÇíË®òÈå≤
  canvas.addEventListener("touchstart", (e) => {
    if (e.touches.length === 1) {
      touchStartY = e.touches[0].clientY;
    }
  }, { passive: true });
  
  // üîßËøΩÂä†Ôºö„Çø„ÉÉ„ÉÅÁßªÂãï‰∏≠„Å´‰∏ÄÂÆöË∑ùÈõ¢‰∏ä„Å´Âãï„ÅÑ„Åü„ÇâÂâçÈÄ≤„Éï„É©„Ç∞ON
  canvas.addEventListener("touchmove", (e) => {
    if (touchStartY === null) return;
  
    const touchY = e.touches[0].clientY;
    const dy = touchStartY - touchY;
  
    if (dy > 50) {
      isMovingForward = true;
      isMovingBackward = false;
    }else if(dy < -50){
      isMovingForward = false;
      isMovingBackward = true;
    }
  }, { passive: true });
  
  // üîßËøΩÂä†Ôºö„Çø„ÉÉ„ÉÅ„ÅåÁµÇ„Çè„Å£„Åü„ÇâÂâçÈÄ≤„Éï„É©„Ç∞OFFÔºÜ„É™„Çª„ÉÉ„Éà
  canvas.addEventListener("touchend", (e) => {
    isMovingForward = false;
    isMovingBackward = false;
    touchStartY = null;
  }, { passive: true });
  

canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1) {
    touchStartY = e.touches[0].clientY;  // ‚ÜêÊó¢Â≠ò„ÅÆYË®òÈå≤ÔºàÂâçÈÄ≤Áî®Ôºâ
    touchStartX = e.touches[0].clientX;  // ‚ÜêüÜï Â∑¶Âè≥ÂõûËª¢Áî®
  }
}, { passive: true });

canvas.addEventListener("touchmove", (e) => {
  if (touchStartY === null || touchStartX === null) return;

  const touchY = e.touches[0].clientY;
  const touchX = e.touches[0].clientX;

  const dy = touchStartY - touchY;
  const dx = touchX - touchStartX;

  // ÂâçÈÄ≤
  if (dy > 50) {
    isMovingForward = true;
  }
  
  if (dx > 50) {
    isTurningRight = true;      // Âè≥„Çπ„ÉØ„Ç§„Éó ‚Üí ÂõûËª¢„Éï„É©„Ç∞ON
    isTurningLeft = false;
  } else if (dx < -50) {
    isTurningLeft = true;       // Â∑¶„Çπ„ÉØ„Ç§„Éó ‚Üí ÂõûËª¢„Éï„É©„Ç∞ON
    isTurningRight = false;
  }

  // Â∑¶Âè≥ÂõûËª¢Ôºà‰∏ÄÂÆöË∑ùÈõ¢Âãï„Åã„Åó„Åü„ÇâÂõûËª¢Ôºâ
  if (dx > 50) {
    rotate(0.2);   // ‚ÜíÂè≥„Å∏ÂõûËª¢ÔºàÂè≥„Çπ„ÉØ„Ç§„ÉóÔºâ
    touchStartX = touchX; // ‚ÜêÂõûËª¢„ÅÆÈÄ£Á∂öÂà§ÂÆöÁî®„Å´Êõ¥Êñ∞
  } else if (dx < -50) {
    rotate(-0.2);  // ‚ÜêÂ∑¶„Å∏ÂõûËª¢ÔºàÂ∑¶„Çπ„ÉØ„Ç§„ÉóÔºâ
    touchStartX = touchX; // ‚Üê„Åì„Å°„Çâ„ÇÇÊõ¥Êñ∞
  }
}, { passive: true });

canvas.addEventListener("touchend", (e) => {
  isMovingForward = false;
  isTurningLeft = false;
  isTurningRight = false;
  touchStartY = null;
  touchStartX = null;  // üîßËøΩÂä†ÔºöXÊñπÂêë„ÅÆË®òÈå≤„ÇÇ„É™„Çª„ÉÉ„Éà
}, { passive: true });
 

  document.addEventListener("keydown", (e) => {
    switch(e.key) {
      case "ArrowLeft":
        rotate(-0.3);
        break;
      case "ArrowRight":
        rotate(0.3);
        break;
      case "ArrowUp":
        move(true);
        break;
      case "ArrowDown":
        move(false);
        break;
    }
    render();
  });

  render();
  

  function gameLoop() {
    
    
    if(isMovingForward){
      move(true);
    }
    
    if(isMovingBackward){
      move(false);
    }
    updateEnemy();
    updateBullets();
    if (isTurningLeft) {
    rotate(-0.05); // ‚Üê Êªë„Çâ„ÅãÂ∑¶ÂõûËª¢
    }
    if (isTurningRight) {
      rotate(0.05);  // ‚Üí Êªë„Çâ„ÅãÂè≥ÂõûËª¢
    }
    
    checkGoalReached();
    render();
    requestAnimationFrame(gameLoop);
    //console.log("Enemy position:", enemyX.toFixed(2), enemyY.toFixed(2));
  
  }


gameLoop(); // ‚Üê „Åì„Çå„Çí script „ÅÆÊúÄÂæå„Å´Êõ∏„ÅèÔºÅ
</script>

</body>
</html>
