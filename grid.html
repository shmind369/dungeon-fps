<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Walking Space</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

```
    #container {
        width: 100vw;
        height: 100vh;
        position: relative;
    }
    
    #instructions {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border-radius: 5px;
        z-index: 100;
        font-size: 14px;
        line-height: 1.4;
        max-width: 300px;
    }
    
    #touchControls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        color: white;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 100;
        font-size: 12px;
        text-align: center;
        display: none;
    }
    
    @media (max-width: 768px) {
        #touchControls {
            display: block;
        }
        #instructions {
            font-size: 12px;
            padding: 10px;
            max-width: 250px;
        }
    }
    
    #crosshair {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 4px;
        height: 4px;
        background: white;
        border-radius: 50%;
        z-index: 100;
        pointer-events: none;
    }
</style>
```

</head>
<body>
    <div id="container">
        <div id="instructions">
            <div><strong>操作方法:</strong></div>
            <div>【PC】</div>
            <div>W/A/S/D または 矢印キー: 移動</div>
            <div>マウス: 視点回転</div>
            <div>Shift: 走る / スペース: ジャンプ</div>
            <div>クリックでマウスロック開始</div>
            <div>Ctrl+クリック: 立方体配置</div>
            <div><strong>【モバイル】</strong></div>
            <div>↑スワイプ: 前進</div>
            <div>↓スワイプ: 後進</div>
            <div>←→スワイプ: 方向転換</div>
            <div>短タップ: ジャンプ</div>
            <div>長押し: 立方体配置</div>
        </div>
        <div id="touchControls">
            スワイプで移動・方向転換 | 短タップでジャンプ | 長押しで立方体配置
        </div>
        <div id="crosshair"></div>
    </div>

```
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // 基本設定
    let scene, camera, renderer;
    let controls = {};
    let velocity = new THREE.Vector3();
    let canJump = false;
    let isRunning = false;
    
    // マウス制御
    let isMouseLocked = false;
    let mouseX = 0, mouseY = 0;
    
    // タッチ制御
    let touchStartX = 0, touchStartY = 0;
    let touchEndX = 0, touchEndY = 0;
    let isMoving = false;
    let moveDirection = 0; // 0: 停止, 1: 前進, -1: 後進
    let turnDirection = 0; // 0: 直進, 1: 右, -1: 左
    let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    let touchStartTime = 0;
    
    // 立方体配置
    let raycaster, mouse;
    let placedCubes = new Map(); // グリッド座標をキーとして立方体を管理
    let floorPlane;
    
    // 物理パラメータ
    const WALK_SPEED = 20;
    const RUN_SPEED = 40;
    const JUMP_VELOCITY = 15;
    const GRAVITY = -50;
    const CAMERA_HEIGHT = 1.8;
    const TURN_SPEED = 2.0;
    const GRID_SIZE = 5; // グリッドの間隔
    
    init();
    animate();
    
    function init() {
        // シーン作成
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 200);
        
        // カメラ作成
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, CAMERA_HEIGHT, 0);
        
        // レンダラー作成
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('container').appendChild(renderer.domElement);
        
        // グリッド床を作成
        createFloor();
        
        // 照明を追加
        addLights();
        
        // レイキャスター初期化
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        
        // イベントリスナー設定
        setupEventListeners();
    }
    
    function createFloor() {
        // メインの床
        const floorGeometry = new THREE.PlaneGeometry(500, 500);
        const floorMaterial = new THREE.MeshLambertMaterial({ 
            color: 0x333333,
            transparent: true,
            opacity: 0.8
        });
        floorPlane = new THREE.Mesh(floorGeometry, floorMaterial);
        floorPlane.rotation.x = -Math.PI / 2;
        floorPlane.receiveShadow = true;
        floorPlane.name = 'floor';
        scene.add(floorPlane);
        
        // グリッドライン
        const gridHelper = new THREE.GridHelper(500, 100, 0x666666, 0x444444);
        scene.add(gridHelper);
        
        // パースペクティブグリッド（画像に似せるため）
        createPerspectiveGrid();
    }
    
    function createPerspectiveGrid() {
        const material = new THREE.LineBasicMaterial({ 
            color: 0x666666,
            transparent: true,
            opacity: 0.6
        });
        
        // 縦線（奥行き方向）
        for (let i = -50; i <= 50; i += 2) {
            const geometry = new THREE.BufferGeometry();
            const points = [
                new THREE.Vector3(i, 0.01, -250),
                new THREE.Vector3(i, 0.01, 250)
            ];
            geometry.setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }
        
        // 横線（左右方向）
        for (let i = -50; i <= 50; i += 2) {
            const geometry = new THREE.BufferGeometry();
            const points = [
                new THREE.Vector3(-250, 0.01, i),
                new THREE.Vector3(250, 0.01, i)
            ];
            geometry.setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
        }
    }
    
    function addLights() {
        // 環境光
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);
        
        // 指向性ライト
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.camera.left = -100;
        directionalLight.shadow.camera.right = 100;
        directionalLight.shadow.camera.top = 100;
        directionalLight.shadow.camera.bottom = -100;
        scene.add(directionalLight);
    }
    
    function setupEventListeners() {
        // キーボードイベント
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        // マウスイベント（PC）
        if (!isMobile) {
            renderer.domElement.addEventListener('click', onMouseClick);
            
            document.addEventListener('pointerlockchange', () => {
                isMouseLocked = document.pointerLockElement === renderer.domElement;
            });
            
            document.addEventListener('mousemove', onMouseMove);
        }
        
        // タッチイベント（モバイル）
        renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
        renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
        renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        
        // ウィンドウリサイズ
        window.addEventListener('resize', onWindowResize);
    }
    
    function onKeyDown(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                controls.forward = true;
                break;
            case 'KeyS':
            case 'ArrowDown':
                controls.backward = true;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                controls.left = true;
                break;
            case 'KeyD':
            case 'ArrowRight':
                controls.right = true;
                break;
            case 'Space':
                if (canJump) {
                    velocity.y = JUMP_VELOCITY;
                    canJump = false;
                }
                event.preventDefault();
                break;
            case 'ShiftLeft':
            case 'ShiftRight':
                isRunning = true;
                break;
        }
    }
    
    function onKeyUp(event) {
        switch (event.code) {
            case 'KeyW':
            case 'ArrowUp':
                controls.forward = false;
                break;
            case 'KeyS':
            case 'ArrowDown':
                controls.backward = false;
                break;
            case 'KeyA':
            case 'ArrowLeft':
                controls.left = false;
                break;
            case 'KeyD':
            case 'ArrowRight':
                controls.right = false;
                break;
            case 'ShiftLeft':
            case 'ShiftRight':
                isRunning = false;
                break;
        }
    }
    
    function onMouseClick(event) {
        if (event.ctrlKey || event.metaKey) {
            // Ctrl+クリックで立方体配置
            placeCubeAtMouse(event);
        } else if (!isMouseLocked) {
            // マウスロック開始
            renderer.domElement.requestPointerLock();
        }
    }
    
    function placeCubeAtMouse(event) {
        // マウス座標を正規化座標に変換
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        placeCubeAtPosition();
    }
    
    function placeCubeAtTouch(touch) {
        // タッチ座標を正規化座標に変換
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
        
        placeCubeAtPosition();
    }
    
    function placeCubeAtPosition() {
        // レイキャスターでクリック位置を計算
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(floorPlane);
        
        if (intersects.length > 0) {
            const intersectPoint = intersects[0].point;
            
            // グリッドに合わせて座標を調整
            const gridX = Math.round(intersectPoint.x / GRID_SIZE) * GRID_SIZE;
            const gridZ = Math.round(intersectPoint.z / GRID_SIZE) * GRID_SIZE;
            const gridKey = `${gridX},${gridZ}`;
            
            // 既に立方体がある場合は削除、ない場合は追加
            if (placedCubes.has(gridKey)) {
                scene.remove(placedCubes.get(gridKey));
                placedCubes.delete(gridKey);
            } else {
                // 立方体を作成
                const cubeGeometry = new THREE.BoxGeometry(GRID_SIZE * 0.8, GRID_SIZE * 0.8, GRID_SIZE * 0.8);
                const cubeMaterial = new THREE.MeshLambertMaterial({ 
                    color: Math.random() * 0xffffff 
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                
                cube.position.set(gridX, GRID_SIZE * 0.4, gridZ);
                cube.castShadow = true;
                cube.receiveShadow = true;
                
                scene.add(cube);
                placedCubes.set(gridKey, cube);
            }
        }
    }
        
    function onMouseMove(event) {
        if (!isMouseLocked || isMobile) return;
        
        mouseX += event.movementX * 0.002;
        mouseY += event.movementY * 0.002;
        
        // 垂直回転を制限
        mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, mouseY));
        
        // カメラ回転を適用
        camera.rotation.order = 'YXZ';
        camera.rotation.y = -mouseX;
        camera.rotation.x = -mouseY;
    }
    
    function onTouchStart(event) {
        event.preventDefault();
        const touch = event.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        touchStartTime = Date.now();
    }
    
    function onTouchMove(event) {
        event.preventDefault();
        const touch = event.touches[0];
        touchEndX = touch.clientX;
        touchEndY = touch.clientY;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > 20) { // 最小スワイプ距離
            const angle = Math.atan2(deltaY, deltaX);
            const degrees = angle * 180 / Math.PI;
            
            // スワイプ方向を判定
            if (Math.abs(deltaY) > Math.abs(deltaX)) {
                // 縦方向のスワイプ
                if (deltaY < -30) {
                    // 上スワイプ - 前進
                    moveDirection = 1;
                    isMoving = true;
                } else if (deltaY > 30) {
                    // 下スワイプ - 後進
                    moveDirection = -1;
                    isMoving = true;
                }
            } else {
                // 横方向のスワイプ - 方向転換
                if (deltaX < -30) {
                    // 左スワイプ
                    turnDirection = -1;
                } else if (deltaX > 30) {
                    // 右スワイプ
                    turnDirection = 1;
                }
            }
        }
    }
    
    function onTouchEnd(event) {
        event.preventDefault();
        const touch = event.changedTouches[0];
        touchEndX = touch.clientX;
        touchEndY = touch.clientY;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const touchDuration = Date.now() - touchStartTime;
        
        // 長押し判定（500ms以上）
        if (touchDuration > 500 && distance < 20) {
            placeCubeAtTouch(touch);
        }
        // タップ判定（短距離の場合）
        else if (distance < 10 && touchDuration < 300 && canJump) {
            velocity.y = JUMP_VELOCITY;
            canJump = false;
        }
        
        // 移動停止
        moveDirection = 0;
        isMoving = false;
    }
    
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function updateMovement(delta) {
        const speed = isRunning ? RUN_SPEED : WALK_SPEED;
        const direction = new THREE.Vector3();
        
        // PC用のキーボード制御
        if (!isMobile) {
            if (controls.forward) direction.z -= 1;
            if (controls.backward) direction.z += 1;
            if (controls.left) direction.x -= 1;
            if (controls.right) direction.x += 1;
            
            // カメラの向きに合わせて方向を回転
            direction.applyQuaternion(camera.quaternion);
            direction.y = 0;
            direction.normalize();
            
            velocity.x = direction.x * speed;
            velocity.z = direction.z * speed;
        } else {
            // モバイル用のタッチ制御
            
            // 方向転換
            if (turnDirection !== 0) {
                mouseX += turnDirection * TURN_SPEED * delta;
                camera.rotation.order = 'YXZ';
                camera.rotation.y = -mouseX;
                camera.rotation.x = -mouseY;
                
                // 方向転換を徐々に減速
                turnDirection *= 0.95;
                if (Math.abs(turnDirection) < 0.1) {
                    turnDirection = 0;
                }
            }
            
            // 移動
            if (isMoving && moveDirection !== 0) {
                direction.z = -moveDirection; // 前進/後進
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0;
                direction.normalize();
                
                velocity.x = direction.x * speed;
                velocity.z = direction.z * speed;
            } else {
                // 移動減速
                velocity.x *= 0.9;
                velocity.z *= 0.9;
            }
        }
        
        // 重力を適用
        velocity.y += GRAVITY * delta;
        
        // 位置を更新
        camera.position.add(velocity.clone().multiplyScalar(delta));
        
        // 床との衝突判定
        if (camera.position.y <= CAMERA_HEIGHT) {
            camera.position.y = CAMERA_HEIGHT;
            velocity.y = 0;
            canJump = true;
        }
        
        // エリア制限
        const limit = 240;
        camera.position.x = Math.max(-limit, Math.min(limit, camera.position.x));
        camera.position.z = Math.max(-limit, Math.min(limit, camera.position.z));
    }
    
    function animate() {
        requestAnimationFrame(animate);
        
        const delta = 0.016; // 約60fps
        updateMovement(delta);
        
        renderer.render(scene, camera);
    }
</script>
```

</body>
</html>