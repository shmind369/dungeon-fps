<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Walking Space - Touch Only</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
            font-size: 14px;
            line-height: 1.4;
            max-width: 300px;
        }
        
        #touchControls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            #instructions {
                font-size: 12px;
                padding: 10px;
                max-width: 250px;
            }
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
        }
        
        #coordinates {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.4;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="instructions">
            <div><strong>タッチ操作:</strong></div>
            <div>↑スワイプ: 前進</div>
            <div>↓スワイプ: 後進</div>
            <div>←スワイプ: 左旋回</div>
            <div>→スワイプ: 右旋回</div>
            <div>長押し: 立方体配置/削除</div>
        </div>
        <div id="touchControls">
            ↑↓で前進・後進 | ←→で旋回 | 長押しで立方体配置
        </div>
        <div id="crosshair"></div>
        <div id="coordinates">
            <div>座標: <span id="coordText">0, 0</span></div>
            <div>向き: <span id="directionText">北</span></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 基本設定
        let scene, camera, renderer;
        let velocity = new THREE.Vector3();
        
        // タッチ制御
        let touchStartX = 0, touchStartY = 0;
        let touchEndX = 0, touchEndY = 0;
        let isMoving = false;
        let moveDirection = 0; // 0: 停止, 1: 前進, -1: 後進
        let turnDirection = 0; // 0: 停止, 1: 右旋回, -1: 左旋回
        let touchStartTime = 0;
        let cameraRotation = 0; // 固定視点の方向（Y軸回転）
        let isRotating = false;
        let rotationVelocity = 0;
        
        // 座標表示
        let coordTextEl, directionTextEl;
        
        // 立方体配置
        let raycaster, mouse;
        let placedCubes = new Map();
        let floorPlane;
        
        // 迷路生成
        const MAZE_SIZE = 16;
        let maze = [];
        let walls = [];
        
        // 物理パラメータ
        const WALK_SPEED = 5;
        const CAMERA_HEIGHT = 1.8;
        const TURN_SPEED = 3; // 旋回速度（ラジアン/秒）
        const GRID_SIZE = 5;
        const WALL_HEIGHT = 4;
        
        // 迷路生成関数
        function generateMaze() {
            // 迷路の初期化（全て壁）
            maze = [];
            for (let y = 0; y < MAZE_SIZE; y++) {
                maze[y] = [];
                for (let x = 0; x < MAZE_SIZE; x++) {
                    maze[y][x] = 1; // 1 = 壁, 0 = 通路
                }
            }
            
            // 迷路生成（深さ優先探索）
            const stack = [];
            const startX = 1, startY = 1;
            maze[startY][startX] = 0; // スタート地点を通路に
            stack.push({x: startX, y: startY});
            
            const directions = [
                {x: 0, y: -2}, // 上
                {x: 2, y: 0},  // 右
                {x: 0, y: 2},  // 下
                {x: -2, y: 0}  // 左
            ];
            
            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];
                
                // 隣接する壁を探す
                for (const dir of directions) {
                    const newX = current.x + dir.x;
                    const newY = current.y + dir.y;
                    
                    if (newX > 0 && newX < MAZE_SIZE - 1 &&
                        newY > 0 && newY < MAZE_SIZE - 1 &&
                        maze[newY][newX] === 1) {
                        neighbors.push({x: newX, y: newY, wallX: current.x + dir.x/2, wallY: current.y + dir.y/2});
                    }
                }
                
                if (neighbors.length > 0) {
                    // ランダムな隣接セルを選択
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    
                    // 壁を取り除く
                    maze[next.wallY][next.wallX] = 0;
                    maze[next.y][next.x] = 0;
                    
                    stack.push({x: next.x, y: next.y});
                } else {
                    stack.pop();
                }
            }
            
            // ゴール地点を作成（右下角近く）
            maze[MAZE_SIZE - 2][MAZE_SIZE - 2] = 0;
        }
        
        function createMazeWalls() {
            // 壁の材質
            const wallMaterial = new THREE.MeshLambertMaterial({
                color: 0x8B4513 // 茶色
            });
            
            // 迷路の壁を生成
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (maze[y][x] === 1) {
                        // 壁を作成
                        const wallGeometry = new THREE.BoxGeometry(GRID_SIZE, WALL_HEIGHT, GRID_SIZE);
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        
                        // 迷路の中心に配置
                        const worldX = (x - MAZE_SIZE / 2) * GRID_SIZE;
                        const worldZ = (y - MAZE_SIZE / 2) * GRID_SIZE;
                        
                        wall.position.set(worldX, WALL_HEIGHT / 2, worldZ);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        
                        scene.add(wall);
                        walls.push(wall);
                    }
                }
            }
            
            // プレイヤーをスタート地点に配置
            const startWorldX = (1 - MAZE_SIZE / 2) * GRID_SIZE;
            const startWorldZ = (1 - MAZE_SIZE / 2) * GRID_SIZE;
            camera.position.set(startWorldX, CAMERA_HEIGHT, startWorldZ);
        }
        
        function checkWallCollision(position) {
            // プレイヤーの衝突判定（円形、半径1.5）
            const playerRadius = 1.5;
            
            // プレイヤー位置を迷路座標に変換
            const mazeX = Math.round((position.x + MAZE_SIZE * GRID_SIZE / 2) / GRID_SIZE);
            const mazeZ = Math.round((position.z + MAZE_SIZE * GRID_SIZE / 2) / GRID_SIZE);
            
            // 範囲外チェック
            if (mazeX < 0 || mazeX >= MAZE_SIZE || mazeZ < 0 || mazeZ >= MAZE_SIZE) {
                return true;
            }
            
            // 周辺のセルをチェック
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const checkX = mazeX + dx;
                    const checkZ = mazeZ + dy;
                    
                    if (checkX >= 0 && checkX < MAZE_SIZE &&
                        checkZ >= 0 && checkZ < MAZE_SIZE &&
                        maze[checkZ][checkX] === 1) {
                        
                        // 壁の中心座標
                        const wallWorldX = (checkX - MAZE_SIZE / 2) * GRID_SIZE;
                        const wallWorldZ = (checkZ - MAZE_SIZE / 2) * GRID_SIZE;
                        
                        // 距離チェック
                        const distance = Math.sqrt(
                            Math.pow(position.x - wallWorldX, 2) +
                            Math.pow(position.z - wallWorldZ, 2)
                        );
                        
                        if (distance < playerRadius + GRID_SIZE / 2) {
                            return true; // 衝突
                        }
                    }
                }
            }
            
            return false; // 衝突なし
        }
        
        init();
        animate();
        
        function init() {
            // シーン作成
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 50, 200);
            
            // カメラ作成（固定高度）
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, CAMERA_HEIGHT, 0);
            camera.rotation.order = 'YXZ';
            
            // レンダラー作成
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // 迷路を生成
            generateMaze();
            
            // グリッド床を作成
            createFloor();
            
            // 迷路の壁を作成
            createMazeWalls();
            
            // 照明を追加
            addLights();
            
            // レイキャスター初期化
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // タッチイベント設定
            setupTouchEvents();
            
            // 座標表示要素取得
            coordTextEl = document.getElementById('coordText');
            directionTextEl = document.getElementById('directionText');
            
            // ウィンドウリサイズ
            window.addEventListener('resize', onWindowResize);
        }
        
        function createFloor() {
            // メインの床（迷路サイズに合わせて調整）
            const floorSize = MAZE_SIZE * GRID_SIZE + GRID_SIZE * 2;
            const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
            const floorMaterial = new THREE.MeshLambertMaterial({
                color: 0x444444,
                transparent: true,
                opacity: 0.9
            });
            floorPlane = new THREE.Mesh(floorGeometry, floorMaterial);
            floorPlane.rotation.x = -Math.PI / 2;
            floorPlane.receiveShadow = true;
            floorPlane.name = 'floor';
            scene.add(floorPlane);
            
            // 迷路用グリッド
            const gridHelper = new THREE.GridHelper(floorSize, MAZE_SIZE, 0x666666, 0x555555);
            scene.add(gridHelper);
        }
        
        function addLights() {
            // 環境光を強くして全体を明るく
            const ambientLight = new THREE.AmbientLight(0x404040, 0.8);
            scene.add(ambientLight);
            
            // 複数の指向性ライトで均等に照明
            const lightPositions = [
                {x: 40, y: 80, z: 40},   // 右上
                {x: -40, y: 80, z: 40},  // 左上
                {x: 40, y: 80, z: -40},  // 右下
                {x: -40, y: 80, z: -40}, // 左下
                {x: 0, y: 100, z: 0}     // 中央上
            ];
            
            lightPositions.forEach((pos, index) => {
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(pos.x, pos.y, pos.z);
                directionalLight.castShadow = index === 0; // 最初のライトのみ影を有効
                
                if (directionalLight.castShadow) {
                    directionalLight.shadow.mapSize.width = 2048;
                    directionalLight.shadow.mapSize.height = 2048;
                    directionalLight.shadow.camera.near = 0.5;
                    directionalLight.shadow.camera.far = 200;
                    directionalLight.shadow.camera.left = -80;
                    directionalLight.shadow.camera.right = 80;
                    directionalLight.shadow.camera.top = 80;
                    directionalLight.shadow.camera.bottom = -80;
                }
                
                scene.add(directionalLight);
            });
        }
        
        function setupTouchEvents() {
            renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', onTouchEnd, { passive: false });
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            const touch = event.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }
        
        function onTouchMove(event) {
            event.preventDefault();
            const touch = event.touches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance > 20) { // スワイプ判定の閾値
                // 縦方向と横方向のスワイプを処理
                if (Math.abs(deltaY) > Math.abs(deltaX)) {
                    // 縦方向のスワイプ - 前進/後進
                    if (deltaY < -30) {
                        // 上スワイプ - 前進
                        moveDirection = 1;
                        isMoving = true;
                    } else if (deltaY > 30) {
                        // 下スワイプ - 後進
                        moveDirection = -1;
                        isMoving = true;
                    }
                } else {
                    // 横方向のスワイプ - 旋回
                    if (-deltaX < -15) {
                        // 左スワイプ - 左旋回
                        turnDirection = -1;
                        isRotating = true;
                    } else if (-deltaX > 15) {
                        // 右スワイプ - 右旋回
                        turnDirection = 1;
                        isRotating = true;
                    }
                }
            }
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
            const touch = event.changedTouches[0];
            touchEndX = touch.clientX;
            touchEndY = touch.clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const touchDuration = Date.now() - touchStartTime;
            
            // 長押し判定（700ms以上）
            if (touchDuration > 700 && distance < 30) {
                placeCubeAtTouch(touch);
            }
            
            // 移動・旋回停止
            moveDirection = 0;
            turnDirection = 0;
            isMoving = false;
            isRotating = false;
        }
        
        function updateRotation(delta) {
            // 旋回処理（前進と同じような速度感）
            if (isRotating && turnDirection !== 0) {
                rotationVelocity = turnDirection * TURN_SPEED;
            } else {
                // 旋回減速
                rotationVelocity *= 0.85;
            }
            
            // 旋回を適用
            cameraRotation += rotationVelocity * delta;
            camera.rotation.y = cameraRotation;
        }
        
        function updateCoordinates() {
            // 座標表示を更新（X, Z座標）
            const x = Math.round(camera.position.x);
            const z = Math.round(camera.position.z);
            coordTextEl.textContent = `${x}, ${z}`;
            
            // 方向表示
            const angle = cameraRotation;
            let direction = '';
            
            // 角度を正規化
            const normalizedAngle = ((angle % (2 * Math.PI)) + (2 * Math.PI)) % (2 * Math.PI);
            
            if (normalizedAngle >= 7 * Math.PI / 4 || normalizedAngle < Math.PI / 4) {
                direction = '北';
            } else if (normalizedAngle >= Math.PI / 4 && normalizedAngle < 3 * Math.PI / 4) {
                direction = '西';
            } else if (normalizedAngle >= 3 * Math.PI / 4 && normalizedAngle < 5 * Math.PI / 4) {
                direction = '南';
            } else {
                direction = '東';
            }
            
            directionTextEl.textContent = direction;
        }
        
        function placeCubeAtTouch(touch) {
            // タッチ座標を正規化座標に変換
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            
            // レイキャスターでタッチ位置を計算
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(floorPlane);
            
            if (intersects.length > 0) {
                const intersectPoint = intersects[0].point;
                
                // グリッドに合わせて座標を調整
                const gridX = Math.round(intersectPoint.x / GRID_SIZE) * GRID_SIZE;
                const gridZ = Math.round(intersectPoint.z / GRID_SIZE) * GRID_SIZE;
                const gridKey = `${gridX},${gridZ}`;
                
                // 既に立方体がある場合は削除、ない場合は追加
                if (placedCubes.has(gridKey)) {
                    scene.remove(placedCubes.get(gridKey));
                    placedCubes.delete(gridKey);
                } else {
                    // 立方体を作成
                    const cubeGeometry = new THREE.BoxGeometry(GRID_SIZE * 0.8, GRID_SIZE * 0.8, GRID_SIZE * 0.8);
                    const cubeMaterial = new THREE.MeshLambertMaterial({
                        color: Math.random() * 0xffffff
                    });
                    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    
                    cube.position.set(gridX, GRID_SIZE * 0.4, gridZ);
                    cube.castShadow = true;
                    cube.receiveShadow = true;
                    
                    scene.add(cube);
                    placedCubes.set(gridKey, cube);
                }
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateMovement(delta) {
            const direction = new THREE.Vector3();
            
            // 移動処理
            if (isMoving && moveDirection !== 0) {
                direction.z = -moveDirection; // 前進/後進
                direction.applyQuaternion(camera.quaternion);
                direction.y = 0;
                direction.normalize();
                
                // 新しい位置を計算
                const newPosition = camera.position.clone();
                const moveVector = direction.clone().multiplyScalar(WALK_SPEED * delta);
                newPosition.add(moveVector);
                
                // 壁との衝突判定
                if (!checkWallCollision(newPosition)) {
                    velocity.x = direction.x * WALK_SPEED;
                    velocity.z = direction.z * WALK_SPEED;
                } else {
                    velocity.x = 0;
                    velocity.z = 0;
                }
            } else {
                // 移動減速
                velocity.x *= 0.85;
                velocity.z *= 0.85;
            }
            
            // 位置を更新
            const newPos = camera.position.clone().add(velocity.clone().multiplyScalar(delta));
            if (!checkWallCollision(newPos)) {
                camera.position.copy(newPos);
            }
            
            // 迷路エリア制限
            const limit = (MAZE_SIZE / 2) * GRID_SIZE;
            camera.position.x = Math.max(-limit, Math.min(limit, camera.position.x));
            camera.position.z = Math.max(-limit, Math.min(limit, camera.position.z));
            
            // 高度固定
            camera.position.y = CAMERA_HEIGHT;
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = 0.016; // 約60fps
            updateMovement(delta);
            updateRotation(delta);
            updateCoordinates();
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
