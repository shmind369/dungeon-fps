<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üè∞ 3D„ÉÄ„É≥„Ç∏„Éß„É≥ËÑ±Âá∫ üè∞</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            background-color: #000;
            color: #fff;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        canvas {
            display: block;
            background: #111;
        }
        #ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        #info {
            font-size: 14px;
            text-align: center;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(2, 80px);
            gap: 10px;
            z-index: 10;
        }
        .control-btn {
            background: rgba(0, 200, 255, 0.7);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            touch-action: manipulation;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }
        .control-btn:active {
            background: rgba(0, 150, 200, 0.9);
        }
        #forward {
            grid-column: 2;
            grid-row: 1;
        }
        #left {
            grid-column: 1;
            grid-row: 2;
        }
        #backward {
            grid-column: 2;
            grid-row: 2;
        }
        #right {
            grid-column: 3;
            grid-row: 2;
        }
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            display: none;
            z-index: 20;
            border: 3px solid #00d4ff;
        }
        #message h2 {
            font-size: 36px;
            margin-bottom: 20px;
        }
        #message button {
            padding: 15px 30px;
            font-size: 18px;
            background: #00d4ff;
            color: #000;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
        }
        #minimap {
            position: absolute;
            top: 60px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00d4ff;
            border-radius: 5px;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui">
            <div id="info">
                üè∞ „ÉÄ„É≥„Ç∏„Éß„É≥ËÑ±Âá∫ | „Ç¥„Éº„É´„ÇíÁõÆÊåá„ÅõÔºÅ | üëª ËøΩË∑°ËÄÖ„Å´Ê≥®ÊÑèÔºÅ
            </div>
        </div>
        <canvas id="canvas"></canvas>
        <canvas id="minimap" width="120" height="120"></canvas>
        <div id="controls">
            <button id="forward" class="control-btn">‚Üë</button>
            <button id="left" class="control-btn">‚Üê</button>
            <button id="backward" class="control-btn">‚Üì</button>
            <button id="right" class="control-btn">‚Üí</button>
        </div>
        <div id="message">
            <h2 id="messageTitle"></h2>
            <p id="messageText"></p>
            <button onclick="restartGame()">„ÇÇ„ÅÜ‰∏ÄÂ∫¶„Éó„É¨„Ç§</button>
        </div>
    </div>

```
<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const minimap = document.getElementById('minimap');
    const minimapCtx = minimap.getContext('2d');

    // „Ç≠„É£„É≥„Éê„Çπ„Çµ„Ç§„Ç∫Ë®≠ÂÆö
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // „Ç≤„Éº„É†Ë®≠ÂÆö
    const MAZE_SIZE = 10;
    const CELL_SIZE = 1;
    const WALL_HEIGHT = 1;
    const FOV = Math.PI / 3;
    const RAY_COUNT = 120;
    const MAX_DEPTH = 20;

    // Ëø∑Ë∑ØÁîüÊàêÔºà0=ÈÄöË∑Ø, 1=Â£Å, 2=„Ç¥„Éº„É´Ôºâ
    let maze = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        [1, 0, 1, 0, 1, 0, 1, 1, 0, 1],
        [1, 0, 1, 0, 0, 0, 0, 1, 0, 1],
        [1, 0, 1, 1, 1, 1, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
        [1, 1, 1, 0, 1, 1, 0, 1, 0, 1],
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 1],
        [1, 0, 1, 1, 0, 0, 0, 1, 2, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ];

    // „Éó„É¨„Ç§„É§„Éº
    let player = {
        x: 1.5,
        y: 1.5,
        angle: 0,
        speed: 0.1
    };

    // ËøΩË∑°ËÄÖÔºàÊïµÔºâ
    let enemy = {
        x: 7.5,
        y: 7.5,
        speed: 0.03,
        moveTimer: 0,
        moveDelay: 20
    };

    let gameState = 'playing'; // playing, win, lose
    let audioContext = null;

    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
    }

    function playSound(frequency, duration, type = 'sine') {
        initAudio();
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        osc.connect(gain);
        gain.connect(audioContext.destination);
        osc.frequency.value = frequency;
        osc.type = type;
        gain.gain.setValueAtTime(0.2, audioContext.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
        osc.start(audioContext.currentTime);
        osc.stop(audioContext.currentTime + duration);
    }

    function playWinSound() {
        playSound(523, 0.15);
        setTimeout(() => playSound(659, 0.15), 150);
        setTimeout(() => playSound(784, 0.3), 300);
    }

    function playLoseSound() {
        playSound(200, 0.5, 'sawtooth');
    }

    // „É¨„Ç§„Ç≠„É£„Çπ„ÉÜ„Ç£„É≥„Ç∞
    function castRay(angle) {
        const rayX = Math.cos(angle);
        const rayY = Math.sin(angle);
        let distance = 0;
        let hitWall = false;
        let hitGoal = false;

        while (!hitWall && !hitGoal && distance < MAX_DEPTH) {
            distance += 0.05;
            const testX = player.x + rayX * distance;
            const testY = player.y + rayY * distance;
            const cellX = Math.floor(testX);
            const cellY = Math.floor(testY);

            if (cellX < 0 || cellX >= MAZE_SIZE || cellY < 0 || cellY >= MAZE_SIZE) {
                hitWall = true;
            } else if (maze[cellY][cellX] === 1) {
                hitWall = true;
            } else if (maze[cellY][cellX] === 2) {
                hitGoal = true;
            }
        }

        return { distance, hitWall, hitGoal };
    }

    // ÊèèÁîª
    function render() {
        // Á©∫„Å®Â∫ä
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
        ctx.fillStyle = '#0f3460';
        ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

        const rayAngleStep = FOV / RAY_COUNT;
        const columnWidth = canvas.width / RAY_COUNT;

        for (let i = 0; i < RAY_COUNT; i++) {
            const rayAngle = player.angle - FOV / 2 + rayAngleStep * i;
            const ray = castRay(rayAngle);
            
            // È≠öÁúºÂäπÊûúË£úÊ≠£
            const correctedDistance = ray.distance * Math.cos(rayAngle - player.angle);
            const wallHeight = (WALL_HEIGHT / correctedDistance) * canvas.height;
            const wallTop = (canvas.height - wallHeight) / 2;

            // Â£Å„ÅÆËâ≤ÔºàË∑ùÈõ¢„Å´Âøú„Åò„Å¶Êöó„Åè„Åô„ÇãÔºâ
            let brightness = Math.max(0, 255 - correctedDistance * 30);
            
            if (ray.hitGoal) {
                ctx.fillStyle = `rgb(${brightness * 0.3}, ${brightness}, ${brightness * 0.3})`;
            } else if (ray.hitWall) {
                ctx.fillStyle = `rgb(${brightness * 0.5}, ${brightness * 0.5}, ${brightness})`;
            } else {
                continue;
            }

            ctx.fillRect(i * columnWidth, wallTop, columnWidth + 1, wallHeight);
        }

        // Êïµ„ÅÆÊèèÁîªÔºà„Éó„É¨„Ç§„É§„Éº„ÅÆË¶ñÁïåÂÜÖ„Å´„ÅÑ„ÇãÂ†¥ÂêàÔºâ
        const enemyAngle = Math.atan2(enemy.y - player.y, enemy.x - player.x);
        const enemyDistance = Math.sqrt(
            Math.pow(enemy.x - player.x, 2) + Math.pow(enemy.y - player.y, 2)
        );
        
        let angleDiff = enemyAngle - player.angle;
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

        if (Math.abs(angleDiff) < FOV / 2 && enemyDistance < MAX_DEPTH) {
            // Êïµ„ÅåÂ£Å„ÅÆÂæå„Çç„Å´„ÅÑ„Å™„ÅÑ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
            const enemyRay = castRay(enemyAngle);
            if (enemyRay.distance > enemyDistance) {
                const enemySize = (WALL_HEIGHT / enemyDistance) * canvas.height * 0.8;
                const enemyScreenX = canvas.width / 2 + (angleDiff / (FOV / 2)) * (canvas.width / 2);
                const enemyTop = (canvas.height - enemySize) / 2;

                // Êïµ„ÇíËµ§„ÅÑÂÜÜ„Å®„Åó„Å¶ÊèèÁîª
                ctx.fillStyle = `rgba(255, 0, 0, ${Math.max(0.3, 1 - enemyDistance / 10)})`;
                ctx.beginPath();
                ctx.arc(enemyScreenX, enemyTop + enemySize / 2, enemySize / 2, 0, Math.PI * 2);
                ctx.fill();

                // ÁõÆ„ÇíÊèèÁîª
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(enemyScreenX - enemySize / 6, enemyTop + enemySize / 3, enemySize / 10, 0, Math.PI * 2);
                ctx.arc(enemyScreenX + enemySize / 6, enemyTop + enemySize / 3, enemySize / 10, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }

    // „Éü„Éã„Éû„ÉÉ„ÉóÊèèÁîª
    function renderMinimap() {
        const cellSize = minimap.width / MAZE_SIZE;
        
        minimapCtx.clearRect(0, 0, minimap.width, minimap.height);

        // Ëø∑Ë∑ØÊèèÁîª
        for (let y = 0; y < MAZE_SIZE; y++) {
            for (let x = 0; x < MAZE_SIZE; x++) {
                if (maze[y][x] === 1) {
                    minimapCtx.fillStyle = '#444';
                } else if (maze[y][x] === 2) {
                    minimapCtx.fillStyle = '#0f0';
                } else {
                    minimapCtx.fillStyle = '#111';
                }
                minimapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
        }

        // „Ç∞„É™„ÉÉ„ÉâÁ∑ö
        minimapCtx.strokeStyle = '#222';
        for (let i = 0; i <= MAZE_SIZE; i++) {
            minimapCtx.beginPath();
            minimapCtx.moveTo(i * cellSize, 0);
            minimapCtx.lineTo(i * cellSize, minimap.height);
            minimapCtx.stroke();
            minimapCtx.beginPath();
            minimapCtx.moveTo(0, i * cellSize);
            minimapCtx.lineTo(minimap.width, i * cellSize);
            minimapCtx.stroke();
        }

        // „Éó„É¨„Ç§„É§„Éº
        minimapCtx.fillStyle = '#00d4ff';
        minimapCtx.beginPath();
        minimapCtx.arc(player.x * cellSize, player.y * cellSize, cellSize / 3, 0, Math.PI * 2);
        minimapCtx.fill();

        // „Éó„É¨„Ç§„É§„Éº„ÅÆÂêë„Åç
        minimapCtx.strokeStyle = '#00d4ff';
        minimapCtx.lineWidth = 2;
        minimapCtx.beginPath();
        minimapCtx.moveTo(player.x * cellSize, player.y * cellSize);
        minimapCtx.lineTo(
            player.x * cellSize + Math.cos(player.angle) * cellSize,
            player.y * cellSize + Math.sin(player.angle) * cellSize
        );
        minimapCtx.stroke();

        // Êïµ
        minimapCtx.fillStyle = '#f00';
        minimapCtx.beginPath();
        minimapCtx.arc(enemy.x * cellSize, enemy.y * cellSize, cellSize / 4, 0, Math.PI * 2);
        minimapCtx.fill();
    }

    // ÁßªÂãïÂà§ÂÆö
    function canMove(newX, newY) {
        const cellX = Math.floor(newX);
        const cellY = Math.floor(newY);
        
        if (cellX < 0 || cellX >= MAZE_SIZE || cellY < 0 || cellY >= MAZE_SIZE) {
            return false;
        }
        
        return maze[cellY][cellX] !== 1;
    }

    // „Éó„É¨„Ç§„É§„ÉºÁßªÂãï
    function moveForward() {
        if (gameState !== 'playing') return;
        const newX = player.x + Math.cos(player.angle) * player.speed;
        const newY = player.y + Math.sin(player.angle) * player.speed;
        if (canMove(newX, newY)) {
            player.x = newX;
            player.y = newY;
        }
    }

    function moveBackward() {
        if (gameState !== 'playing') return;
        const newX = player.x - Math.cos(player.angle) * player.speed;
        const newY = player.y - Math.sin(player.angle) * player.speed;
        if (canMove(newX, newY)) {
            player.x = newX;
            player.y = newY;
        }
    }

    function turnLeft() {
        if (gameState !== 'playing') return;
        player.angle -= 0.1;
    }

    function turnRight() {
        if (gameState !== 'playing') return;
        player.angle += 0.1;
    }

    // Êïµ„ÅÆAIÔºà„Éó„É¨„Ç§„É§„Éº„ÇíËøΩË∑°Ôºâ
    function updateEnemy() {
        if (gameState !== 'playing') return;

        enemy.moveTimer++;
        if (enemy.moveTimer < enemy.moveDelay) return;
        enemy.moveTimer = 0;

        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0.3) {
            const moveX = (dx / distance) * enemy.speed;
            const moveY = (dy / distance) * enemy.speed;
            
            const newX = enemy.x + moveX;
            const newY = enemy.y + moveY;

            if (canMove(newX, enemy.y)) {
                enemy.x = newX;
            }
            if (canMove(enemy.x, newY)) {
                enemy.y = newY;
            }
        }
    }

    // Ë°ùÁ™ÅÂà§ÂÆö
    function checkCollisions() {
        if (gameState !== 'playing') return;

        // „Ç¥„Éº„É´Âà§ÂÆö
        const cellX = Math.floor(player.x);
        const cellY = Math.floor(player.y);
        if (maze[cellY][cellX] === 2) {
            gameState = 'win';
            playWinSound();
            showMessage('üéâ „ÇØ„É™„Ç¢ÔºÅ üéâ', '„ÉÄ„É≥„Ç∏„Éß„É≥„Åã„ÇâËÑ±Âá∫ÊàêÂäüÔºÅ');
        }

        // Êïµ„Å®„ÅÆË°ùÁ™ÅÂà§ÂÆö
        const dx = player.x - enemy.x;
        const dy = player.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 0.5) {
            gameState = 'lose';
            playLoseSound();
            showMessage('üíÄ „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº üíÄ', 'ËøΩË∑°ËÄÖ„Å´Êçï„Åæ„Å£„Å¶„Åó„Åæ„Å£„Åü...');
        }
    }

    // „É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
    function showMessage(title, text) {
        document.getElementById('messageTitle').textContent = title;
        document.getElementById('messageText').textContent = text;
        document.getElementById('message').style.display = 'block';
    }

    // „Ç≤„Éº„É†„É™„Çπ„Çø„Éº„Éà
    function restartGame() {
        player.x = 1.5;
        player.y = 1.5;
        player.angle = 0;
        enemy.x = 7.5;
        enemy.y = 7.5;
        enemy.moveTimer = 0;
        gameState = 'playing';
        document.getElementById('message').style.display = 'none';
    }

    // „Ç≥„É≥„Éà„É≠„Éº„É´
    document.getElementById('forward').addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveForward();
    });
    document.getElementById('forward').addEventListener('click', moveForward);

    document.getElementById('backward').addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveBackward();
    });
    document.getElementById('backward').addEventListener('click', moveBackward);

    document.getElementById('left').addEventListener('touchstart', (e) => {
        e.preventDefault();
        turnLeft();
    });
    document.getElementById('left').addEventListener('click', turnLeft);

    document.getElementById('right').addEventListener('touchstart', (e) => {
        e.preventDefault();
        turnRight();
    });
    document.getElementById('right').addEventListener('click', turnRight);

    // „Ç≠„Éº„Éú„Éº„ÉâÂØæÂøú
    document.addEventListener('keydown', (e) => {
        if (e.key === 'ArrowUp' || e.key === 'w') moveForward();
        if (e.key === 'ArrowDown' || e.key === 's') moveBackward();
        if (e.key === 'ArrowLeft' || e.key === 'a') turnLeft();
        if (e.key === 'ArrowRight' || e.key === 'd') turnRight();
    });

    // „Ç≤„Éº„É†„É´„Éº„Éó
    function gameLoop() {
        updateEnemy();
        checkCollisions();
        render();
        renderMinimap();
        requestAnimationFrame(gameLoop);
    }

    gameLoop();
</script>
```

</body>
</html>